# 브라우저 렌더링 과정



#### ✔브라우저란?

**사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것**

이때 자원은 HTML문서, PDF, 이미지 등 다양한 형태를 띌 수 있다. 자원의 주소는 URL(Uniform Resource Identifier)에 의해 정해진다.

예) 파이어폭스, 사파리, 크롬 등



#### ✔렌더링

서버로부터 HTML, CSS, JavaScript 등 작성한 파일을 받아 브라우저에 시각적으로 출력하는 과정.



#### ✔파싱

프로그래밍 언어로 작성된 파일을 실행시키기 위해 구문 분석(syntax analysis)을 하는 단계이다. 파일의 문자열들을 문법적 의미를 갖는 최소 단위인 '토큰'으로 분해하고, 이 토큰들을 문법적 의미와 구조에 따라 노드라는 요소로 만든다. 노드들은 상하관계를 반영해 트리를 형성하는데, 이 트리를 파스트리라고 한다.



## 브라우저 렌더링 순서

![render path](https://velog.velcdn.com/images/zaman17/post/7281bb76-19be-4307-b6b9-4e849b3123a9/image.png)



> 💫 미리보기
>
> 1. 브라우저는 HTML, CSS, JS, 이미지, 폰트 등 리소스를 서버에 요청하고, 응답으로 받아온다.
> 2. 브라우저 렌더링 엔지는 받아온 HTML, CSS를 파싱해 DOM, CSSOM을 생성하고, 이들을 결합해 렌더 트리를 생성한다.
> 3. 브라우저 JS 엔진은 받아온 JS를 파싱해 AST를 생성하고, 바이트코드로 변환해 실행한다.
> 4. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치, 크기)을 계산한다.
> 5. 화면에 HTML 요소를 페인팅한다.



### 1. 요청, 응답

> Step1. 브라우저는 HTML, CSS, JS, 이미지, 폰트 등 리소스를 서버에 요청하고, 응답으로 받아온다.



**브라우저는 우선 필요한 리소스(HTML, CSS, JS, 이미지, 폰트 등)를 서버에 요청하고, 응답으로 받아와야 한다.**

![서버 요청 방법](16%ED%9A%8C%EC%B0%A8_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%A0%8C%EB%8D%94%EB%A7%81%20%EA%B3%BC%EC%A0%95_%EC%A0%95%EC%95%84%ED%98%84.assets/scode=mtistory2&fname=https%253A%252F%252Fblog.kakaocdn.net%252Fdn%252FSc99Y%252Fbtq66UOgb8s%252FeUxkSArGOuOQdc3jrqXdkK%252Fimg.png)



브라우저에 있는 주소창을 통해 서버에 요청을 전송한다. 주소창에 URL을 입력하고 엔터키를 누르면, URL의 호스트 이름이 DNS(도메인 네임 서비스)를 통해 진짜 주소인 IP주소로 변환되고, 이 IP주소를 갖는 서버에게 요청을 보낸다.

서버는 기본적으로 보통 index.html을 응답으로 주도록 설정되어 있다. 예를 들어, 우리가 `https://www.google.com` 을 검색하면 사실은`https://www.google.com/index.html`을 요청하는 것과 다름 없다. 이 요청에 대해 구글 서버는 클라이언트에 `index.html` 파일을 전달해 줄 것이다. 다른 파일을 요청하고 싶다면 뒤에 다른 파일 경로를 적거나, Javascript를 통해서 동적으로 요청할 수도 있다.

브라우저 렌더링 엔진은 HTML 파일을 파싱할 때, 위에서 아래로 한 줄 한 줄 파싱한다. 그러다가 외부 리소스를 가져오는 태그를 만나면  리소스 파일을 서버로 요청한다. 보통 CSS파일은 `<link>`, Javascript파일은 `<script>`, 이미지는 `<img>`로 가져오는데, 이런 태그들을 만나 리소스들을 서버에서 받아오는 것이다.



### 2-1. HTML파싱, DOM 생성

> Step2. 브라우저 렌더링 엔진은 받아온 HTML, CSS를 파싱해 DOM, CSSOM을 생성하고, 이들을 결합해 렌더 트리를 생성한다.

응답으로 받아온 HTML 문서는 오직 텍스트로만 이루어져 있다. 이 텍스트를 우리가 보는 화면으로 바꾸기 위해서는, 먼저 이 문서를 **브라우저가 이해할 수 있는 형태로 바꾸는 작업**이 필요하다. 여기서 말하는 형태가 바로 **DOM구조** 이다.

![브라우저to돔](16%ED%9A%8C%EC%B0%A8_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%A0%8C%EB%8D%94%EB%A7%81%20%EA%B3%BC%EC%A0%95_%EC%A0%95%EC%95%84%ED%98%84.assets/scode=mtistory2&fname=https%253A%252F%252Fblog.kakaocdn.net%252Fdn%252F9fDtp%252Fbtq66U8yC1x%252F8nUOEWg2HMPiCLHFO2uTX1%252Fimg.png)

**1. 바이트(Bytes)** : 서버는 브라우저에게 2진수 형태의 HTML 문서를 응답으로 준다.

**2. 문자열(Characters)** : 문서는 `<meta>`의 charset 속성에 지정된 방식으로 문자열로 인코딩 된다.(ex. UTF-8) 서버는 이 인코딩 방식은 응답 헤더에 담아준다.

**3. 토큰(Tokens)** : 문자열 형태의 HTML문서를 '토큰'단위로 분해한다. (문법적 의미를 갖는 코드의 최소 단위)

**4. 노드(Nodes)** : 각 토큰을 객체로 변환해, 노드를 생성한다. (DOM을 구성하는 기본 요소)

**5. DOM** : HTML문서의 요소들의 중첩관계를 기반으로 노드들을 트리 구조로 구성한다. 이 트리를 DOM이라고 한다.

위와 같은 과정을 거쳐서 HTML 문서가 파싱되고, DOM 이라는 결과물을 생성하게 된다.

**DOM**(Document Object Model) : 우리말로는 문서 객체 모델. 말 그래도 문서를 → 객체로 바꾼 모델이다.

브라우저는 Javascript 언어만 알아듣는데, Javascript는 HTML의 태그나 속성들을 바로 다룰 수 없기 때문에, 다룰 수 있는 형태인 '객체'로 바꿔 주어야 한다. 그래야 브라우저도 HTML 문서를 이해할 수 있게 된다.





### 2-2. CSS 파싱, CSSOM 생성

CSS 파일도 HTML과 마찬가지로 파싱을 한다. 서버에서 받아온 2진수 파일을 문자열로 인코딩하고, 토큰 단위로 나누고, 노드를 생성하고, 트리를 만든다. 이렇게 파싱해 만든 트리는 **CSSOM** 이라고 한다.

![CSSOM](16%ED%9A%8C%EC%B0%A8_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%A0%8C%EB%8D%94%EB%A7%81%20%EA%B3%BC%EC%A0%95_%EC%A0%95%EC%95%84%ED%98%84.assets/scode=mtistory2&fname=https%253A%252F%252Fblog.kakaocdn.net%252Fdn%252FbioSRx%252Fbtq7jznwYHh%252F4CFBpk9kMvSDVgcjk9ETdK%252Fimg.png)

**CSSOM**(CSS Object Model): CSS 문서를 객체 모델로 바꾼 것. CSS를 생성하고 나면, HTML파일은 다시 본론으로 돌아가 파싱을 멈췄던 부분부터 다시 파싱을 시작해 DOM을 마저 생성한다.

조금 다른 점은 CSS의 속성은 상속이 되기 때문에, 이를 반영한다는 점이다. 예를 들어,  `ul` 이 부모 요소이고, `li`를 자식요소로 가진다고 생각해보자. 아래 코드처럼 `ul는` 파란색 속성을 가지고 있는데, 이 속성은 자식 요소인 `li`도 상속 받게 된다. 따라서 `li`는 상속 받은 `color:blue`와 자신이 가지고 있던 font-size 속성 두 가지를 갖게 된다.

```js
ul {
  color : blue;
}
li {
	font-size : 10px;
}
```



### 2-3. 렌더 트리 생성

DOM과 CSSOM은 굉장히 비슷하게 생겼지만, 서로 다른 속성들을 가진 독립적인 트리들이다. HTML은 구조를, CSS는 디자인을 담당하기 때문에 둘을 합치는 작업이 필요하다.

**렌더 트리**는 이름처럼 **렌더링을 목적으로 만드는 트리**이다. 렌더링은 브라우저가 이제 진짜로 사용자에게 보여주기 위한 화면을 그리는 과정이기 때문에, **보이지 않을 요소들은 이 트리에 포함하지 않는다**. 예를 들어, DOM에서는 `meta`태그 같은 정보 전달 목적의 태그나, CSSOM에서는 **`display:none`**으로 보이지 않게 해둔 요소 (정확히는 노드)들은 **렌더 트리에서는 제외**된다. (단, visibility: hidden은 레이아웃 트리에 포함되니 주의)

![렌더 트리](16%ED%9A%8C%EC%B0%A8_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%A0%8C%EB%8D%94%EB%A7%81%20%EA%B3%BC%EC%A0%95_%EC%A0%95%EC%95%84%ED%98%84.assets/scode=mtistory2&fname=https%253A%252F%252Fblog.kakaocdn.net%252Fdn%252FdsEOio%252Fbtq7ix4Na8d%252FiJRqJupNtVnwqXRNjJj33K%252Fimg.png)

위의 그림처럼 **DOM, CSSOM 에 있던 속성들이 합쳐져 렌더트리를 구성**하는 것을 확인할 수 있다. 

 렌더트리는 아직까지도 텍스트로 구성된 객체로밖에 보이지 않는다. 실제로 우리가 보는 페이지를 만들기 위해서는 '페인팅'이라는 작업을 거쳐야 한다. 페인팅 작업은 렌더트리의 노드들이 가지고 있는 속성들을 바탕으로 이루어진다.



### 3. JavaScript 파싱

> Step3. 브라우저 JS 엔진은 받아온 JS를 파싱해 AST를 생성하고, 바이트코드로 변환해 실행한다.

렌더링 엔진은 HTML 파일을 한 줄 씩 파싱하며 DOM을 생성하다가 Javascript 코드들 불러오는 `<script>` 태그를 만날 때도 파싱을 잠시 멈춘다. 

그리고 src 속성에 적혀있는 파일을 서버에 요청해 받아온다. 이렇게 받아온 **js파일도 마찬가지로 파싱**을 해야하는데, 이 파싱은 브라우저 렌더링 엔진이 직접하지 않고, **Javascript 엔진이 담당**하게 된다. 

이 때 렌더링 엔진은 JS엔진에게 제어권을 아예 넘겨주기 때문에, HTML 파싱을 멈췄다가 js파싱이 다되면 다시 제어권을 돌려받아 파싱을 다시 시작한다.

**JS엔진은 js파일의 코드를 파싱해서 컴퓨터가 이해할 수 있는 기계어로 변환하고 실행**한다. 

좀 더 구체적으로 살펴보면, 먼저 단순한 텍스트 **문자열인 코드를 토큰 단위로 분해**한다. 이렇게 분해된 토큰에 문법적인 의미와 구조가 더해져, **AST(추상 구문 트리) 라는 트리가 완성**된다. 아래 그림에서 맨 왼쪽의 코드가 바로 다음의 트리 구조로 바뀌는 부분이 여기까지의 내용에 해당한다.

![ast 트리](16%ED%9A%8C%EC%B0%A8_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%A0%8C%EB%8D%94%EB%A7%81%20%EA%B3%BC%EC%A0%95_%EC%A0%95%EC%95%84%ED%98%84.assets/scode=mtistory2&fname=https%253A%252F%252Fblog.kakaocdn.net%252Fdn%252FbCNpQR%252Fbtq66UnbSjn%252F0jiGtTizZ4kDtWylZNkSZK%252Fimg.png)

이제 이렇게 코드를 해석해서 만든 AST라는 트리를 실제로 실행할 수 있도록 만들어야 한다. 

코드의 실제 실행은 인터프리터가 담당하는데, 인터프리터가 알아들을 수 있도록 하기 위해서는 **AST트리를 바이트 코드라는 중간 수준의 코드로 변환**해야 한다. 이 변환은 **바이트코드 생성기**가 담당한다. 

이제 위의 그림에서 가장 오른쪽에 있는 형태로 바뀌어 받아온 js파일 내용이 실제로 실행된다.



### 4. 레이아웃(리플로우)

> Step4. 렌더트리를 기반으로 HTML 요소의 레이아웃(위치, 크기)을 계산한다.

레이아웃은 요소의 **기하학적 속성들을 찾는 과정**이다. 

렌더트리에는 요소들의 위치나 크기와 관련된 정보들이 들어있었다. 하지만 이 정보들은 각 요소들에 대한 정보일 뿐, 전체 화면에서 정확히 어디에 위치할 것 인지에 대해서는 아직 알지 못한다. 이런 계산을 하는 단계가 레이아웃 단계이다. 

브라우저는 **각 요소들이 전체 화면에서 어디에, 어떤 크기로 배치되어야 할 지 파악하기 위해 렌더트리의 맨 윗부분부터 아래로 내려가며 계산을 진행**한다. **모든 값들은 절대적인 단위인 px값으로 변환**된다.

예를들어 우리가 `<div>`요소 하나만 띄우도록 코드를 작성했고, width를 50%로 지정해두었다면, 이 값은 전체 화면 크기(viewport)의 절반 크기로 계산되고, 절대적인 값인 px 단위로 변환되는 식이다.

css는 선택자에 따라서 적용되는 태그가 다르기 때문에 모든 css 스타일을 분석해 태그에 스타일 규칙이 적용되게 결정된다.



### 5. 페인팅

> Step5. 화면에 HTML 요소를 페인팅한다.

브라우저 화면은 픽셀이라고 하는 정말 작은 점들로 이루어져 있다. 각각 **정보를 가진 픽셀들이 모여 하나의 이미지, 화면을 구성**하는 것이다. 따라서 화면에 색상을 입히고, 어떤 요소를 보여주기 위해서는 이 픽셀에 대한 정보가 있어야 한다. 

**페인팅**은 이러한 **픽셀들을 채워나가는 과정**이다. 따라서 이 과정을 마지막으로 우리는 단순한 텍스트에 불과했던 파일 내용들을 이미지화된 모습으로 브라우저 화면을 통해 볼 수 있게 된다.

✔ 리플로우 : 레이아웃 계산을 다시 하는 것

✔ 리페인트 : 새로운 렌더트리를 바탕으로 다시 페인트를 하는 것

❗❗  참고로 자바스크립트가 DOM, CSSOM 을 변경하는 경우, 리렌더링







## Reference

[브라우저 렌더링 순서와 원리](https://velog.io/@zaman17/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%88%9C%EC%84%9C%EC%99%80-%EC%9B%90%EB%A6%AC)

[웹페이지가 사용자에게 보여지기까지(브라우저 렌더링 과정)](https://joooing.tistory.com/entry/rendering)