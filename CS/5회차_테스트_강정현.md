## 테스트

작성한 코드가 잘 작동되는지 확인하는 작업.



### 테스트 자동화

테스트 코드를 작성하여, 테스트 시스템이 프로그램의 기능을 자동으로 확인할 수 있게 하는 것.



### 테스트 자동화의 이점

- 반복적인 테스트 작업으로 인한 테스트 비용이 줄어듦.
- 테스트가 누락되거나 잘못 검증하는 등의 실수를 방지할 수 있음.
- 효율적인 리팩토링으로 인한 코드 품질의 향상.



### 좋은 테스트의 조건

**실행 속도가 빨라야 한다.** 코드를 수정할 때마다 빠른 피드백을 받을 수 있다.

**내부 구현 변경 시 테스트가 깨지지 않아야 한다.** 작은 리팩토링으로도 테스트가 깨진다면 오히려 비용이 증가하게 된다.

**버그를 검출할 수 있어야 한다.** 즉, 잘못된 코드를 검증하는 테스트는 실패해야 한다. 테스트 명세는 구체적이어야 하며, 모의 객체(Mock)의 사용은 최대한 지양한다 (의존성 있는 객체의 동작이 바뀌어도, 버그를 검출하지 못한다).

> **모의 객체 Mock**
>
> 백엔드 개발이 완료되기 전에, 프론트 단에서 Mock Data 즉 가짜 데이터를 생성하여 개발 진행.

**테스트의 결과가 안정적이어야 한다.** 특정 기기에서만 성공하는 테스트 등은 신뢰할 수 없다. 테스트는 외부 환경-시간, OS, 네트워크 상태 등-의 영향을 최소화해서 언제 어디서 실행해도 동일한 결과를 보장해야 한다. 

**의도가 명확히 드러나야 한다.** 테스트 코드를 보고 한 눈에 어떤 내용을 테스트하는 지 파악할 수 있어야 한다.



<br/>

## TDD (Test Driven Development)

요구사항을 검증하는 테스트 케이스를 먼저 작성한 후, 테스트 케이스를 통과하기 위한 최소한의 코드를 생성하고, 코드에 대한 리팩토링을 진행하는 방법론.

기능 하나를 추가할 때 테스트 코드를 작성하고, 제대로 작동하는지 확인하면서, 그 기능이 다른 기능에 영향을 미치는 지 테스트할 수 있다.



### TDD 의 3가지 절차

#### 실패

실패하는 테스트 케이스를 먼저 만든다. 

프로젝트의 전체 기능에 대하여 처음부터 모든 테스트 케이스를 작성하는 것이 아니라, <u>지금 가장 먼저 구현할 기능 하나씩 테스트 케이스를 작성</u>한다.

```javascript
// sum() 이 없으니 error.
it("a+b", () => {
    expect(sum(1, 3)).toBe(4); // 테스트 실패
}
```



#### 성공

실패하는 테스트 케이스를 통과시키기 위해, 코드를 작성하여 테스트를 통과시킨다.

> ❗️테스트를 통과시키기 위한 목적으로만 작성한다. 아직 존재하지 않은 많은 문제들을 생각하지 않고, 테스트의 목표에 집중하여 작성하는 것이 중요하다.

```javascript
// 일단 테스트가 통과하게 만들기.
function sum(a, b){
    return 4;
}

it("a+b", () => {
    expect(sum(1, 3)).toBe(4); // 테스트 통과
}
```



#### 리팩토링

구현한 코드에 중복되는 코드가 있거나, 혹은 더 개선시킬 방법이 있다면 리팩토링을 진행한다.

리팩토링을 진행하고 나서도 테스트 케이스가 성공하는지 확인한다.

```javascript
// 정상적으로 동작하게 코드 수정.
function sum(a, b){
    return a + b;
}

it("a+b", () => {
    expect(sum(1, 3)).toBe(4);
}
```





### TDD 의 장점

- 테스트를 먼저 작성함으로써, 구현하려는 동작에 대해 먼저 생각하고 특정한 요구사항에 맞는 코드를 작성할 수 있다.
- 코드의 유지보수성을 향상시킨다.
- 코드 수정 시 기존 코드에 영향을 받는 여러 부분과 그에 따른 문제점을 미리 파악할 수 있다.
- 애플리케이션에 대한 신뢰성이 향상된다.



<br/>

## 유닛 테스트

- 코드의 Unit 단위로 테스트를 진행한다. 단일 컴포넌트나 단일 서비스 등으로, 시스템의 전체적인 동작에 중점을 맞추지 않는다.
- 각 단위가 예상대로 작동하고, 요구사항을 충족하는 지 확인한다.
- Tool: Jasmine, Jest, Karma, Mocha
- 예시: 
  - 컴포넌트가 잘 렌더링 된다.
  - 컴포넌트의 특정 함수를 실행하면, 상태가 우리가 원하는 형태로 바뀐다.
  - 리덕스의 액션 생성 함수가 액션 객체를 잘 만들어 낸다.
  - 리덕스의 리듀서에 상태와 액션 객체를 넣어서 호출하면 새로운 상태를 잘 만들어준다.


<br/>

## 통합 테스트

- 통합된 기능, 즉 유닛 간 데이터를 주고 받는 환경을 테스트한다.
- 시스템의 여러 단위 또는 구성 요소 간의 상호 작용을 검증한다.
- Tool: Jest, Testing Library - 리액트 공식 문서 권장
- 예시:
  - 여러 컴포넌트들이 서로 상호작용을 잘 하고 있다.
  - DOM 이벤트를 발생시켰을 때 UI가 잘 작동된다.
  - 리덕스와 연동된 컨테이너 컴포넌트의 DOM 에 특정 이벤트를 발생시켰을 때, 우리가 원하는 액션이 잘 디스패치 된다. 


<br/>

## E2E 테스트

- End to End 의 약자로, 사용자부터 백엔드 까지 브라우저 동작을 자동화하여 테스트를 진행한다.
- 유저 시나리오 중심으로, 사용자 입장에서 전체 Flow 가 정상적으로 동작하는지 확인한다.
- Tool: Cypress, Pupperteer

- 예: 상품을 구매하는 경우
  1. 고객 로그인
  2. 상품을 선택하여 장바구니에 추가
  3. 상품 구매
  4. 결제 방식 선택
  5. 구매 완료
  6. 구매 영수증을 고객 메일로 전송



---
**Reference**

[벨로퍼트와 함께하는 리액트 테스팅](https://velog.io/@velopert/react-testing)

[TDD의 소개](https://velog.io/@velopert/TDD%EC%9D%98-%EC%86%8C%EA%B0%9C)

[프론트엔드 테스트 - TDD와 종류(Unit, Integration, E2E)](https://soojae.tistory.com/74)

[프론트엔드에서 테스트코드 짜기](https://kooku0.github.io/blog/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C%20%EC%A7%9C%EA%B8%B0/)

