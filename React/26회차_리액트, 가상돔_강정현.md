## React란
>Facebook (현 Meta)에서 만든 JavaScript 사용자 인터페이스 라이브러리.
>기존보다 빠른 UI 렌더링과 반응성 등을 충족시키기 위해 만듦.

웹 개발이 복잡새짐에 따라 html, css, js만으로 한계가 생겼으며, 초기에는 웹 개발을 위한 프론트엔드 라이브러리로 [[DOM]] 조작을 쉽게 해주는 [[jQuery]] 라이브러리가 주로 사용되었다.
그러나, 이후 DOM을 직접 조작하는 방식에 한계를 느껴, 대규모 프로젝트에 효율적으로 코드를 관리하고, 컴포넌트 기반의 UI 개발을 지원하는 프론트엔드 프레임워크(라이브러리)가 등장. - Angular, React, Vue.js

> **프레임워크 vs. 라이브러리**
>
>  프레임워크
> 
> 	- 개발을 위한 기본 구조와 규칙을 제공하는 도구. 개발자는 프레임워크가 제공하는 규칙과 인터페이스에 따라 코드를 작성해야 함.
> 	- 프레임워크는 애플리케이션의 흐름과 제어를 관리하며, 필요한 기능과 도구를 제공함.
> 	- Spring, Angular, Vue 등.
> 
>  <br/>
>  라이브러리
> 
> 	- 개발을 위해 재사용 가능한 코드의 집합이며, 특정 기능을 수행하는 함수, 클래스, 모듈 등으로 구성됨.
> 	- 라이브러리는 개발자가 필요한 기능을 호출하여 사용할 수 있음.
> 	- 라이브러리는 프레임워크와는 달리, 개발자가 코드의 흐름과 제어를 직접 관리함.
> 	- jQuery, React, Express, Axios 등.

### React = 라이브러리
- 사용자 인터페이스(UI) 개발에 초점을 맞춘 라이브러리로, 사용자 인터페이스의 개발을 돕는 도구와 기능을 제공함. 
- 애플리케이션의 전체 구조나 아키텍처를 결정하지 않으며, **개발자는 필요한 부분에 리액트를 적용**하여 UI를 구성하고 관리할 수 있음.
- **컴포넌트 기반 아키텍처**를 기반으로 하여 재사용성과 유지보수성을 높일 수 있도록 함.

<br/>

## React를 사용하는 이유
1. 자바스크립트 기반의 문법을 사용하여, 보다 쉽게 사용 가능함.
2. 가볍고 유연하여, 필요한 부분에만 적용할 수 있어 기존 프로젝트에 리액트를 통합하기 쉽게 만들 수 있다. 또한, 다른 프레임워크나 라이브러리와의 혼용도 가능하므로, 기존 코드를 변경하지 않고도 리액트를 도입할 수 있음.
3. 방대한 커뮤니티와 생태계를 보유하여, 문제 해결을 위한 자료와 지원을 쉽게 얻을 수 있으며, 다양한 라이브러리와 도구를 활용하여 개발 생산성을 높일 수 있음.

<br/>

## React의 특성
### 가상 DOM (Virtual DOM)
자바스크립트를 사용하여 DOM을 조작하며 HTML, CSS에 접근하면 각 노드의 좌표를 계산하기 위해 레이아웃 과정이 다시 실행되고, 페인팅 과정을 거치게 됨 (리플로우, 리페인트). 이러한 과정이 많이 수행될수록, 웹 서비스의 성능이 저하될 수 있음.

리플로우/리페인트가 자주 수행되는 문제를 해결하기 위해, 
1) 화면에 표시되는 DOM과 동일한 DOM을 메모리상에 만들고, 
2) DOM 조작이 발생하면 메모리 상에 생성한 가상 돔에 모든 연산을 수행한 후, 
3) 실제 DOM을 갱신하여 리플로우/리페인트 연산을 최소화 함.
#### React가 가상 DOM을 반영하는 절차
1. **특정 페이지에 변화가 일어남**: 데이터가 업데이트되면, 전체 UI를 가상 DOM에 리렌더링.
2. **가상 DOM끼리 비교**: 변화 전의 가상 DOM과 변화된 가상 DOM을 비교.
3. **바뀐 부분만 적용**: 바뀐 부분만 실제 DOM에 적용하여, 레이아웃 계산은 한 번만 이행됨.
![가상DOM 반영 절차](https://velog.velcdn.com/images%2Fmollog%2Fpost%2Ffdc15800-579c-457c-aa26-3b4c916c9c1e%2Fimage.png)

<br/>

### 단방향 데이터 바인딩 (One-way Data Binding)
> **데이터 바인딩**
> 두 데이터 혹은 정보의 소스를 일치시키는 기법으로, **화면에 보이는 데이터(View)** 와 **브라우저 메모리에 있는 데이터 (여러 개의 자바스크립트 객체, Model)** 를 동기화하는 것.

자바스크립트(Model)에서 HTML(View)로 한 방향으로만 데이터를 동기화하는 것을 의미함. [JS(Model) -> HTML(View)] 
- HTML을 통해 자바스크립트의 데이터를 갱신할 때는, 이벤트를 통해 갱신함.

컴포넌트 간에서, **부모 컴포넌트에서 자식 컴포넌트로만 데이터가 전달**되는 구조.

#### 양방향 데이터 바인딩 (Two-way Data Binding)
자바스크립트(Model)에서 HTML(View) 사이에 ViewModel이 존재하여 하나로 묶여서(Binding), 둘 중 하나만 변경되어도 함께 변경되는 것을 의미함. [HTML(View) <-> ViewModel <-> JavaScript(Model)]

컴포넌트 간에서, **부모 컴포넌트에서 자식 컴포넌트로는 Props**를 통해 데이터를 전달하고, **자식 컴포넌트에서 부모 컴포넌트로는 Emit Event**를 통해 데이터를 전달하는 구조.

<br/>

### 컴포넌트 기반 아키텍처
> **컴포넌트 (Component)**
> 재사용 가능한 각각의 독립된 모듈.

컴포넌트 단위로 UI를 구성하면, 
- 코드 재활용성 증가 
- 코드 유지보수 용이 
- 해당 페이지가 어떻게 구성되어 있는지 파악이 용이하다.

<br/>

### JSX 문법
> **JSX(JavaScript Syntax Extension)**: 자바스크립트 확장 문법으로, 자바스크립트와 HTML을 합쳐놓은 듯한 형태.
> 마크업을 편리하게 작성하기 위한 문법으로 HTML에서 마크업하고, 자바스크립트에서 로직을 연결하고 붙이는 과정을 **하나의 자바스크립트 파일 내에서 처리**할 수 있다.
> JSX로 작성한 코드는 자바스크립트가 인식할 수 없는 문법이기에, `Babel`을 사용해야 한다.
```jsx
const element = <h1>Hello, World!</h1>
```
HTML 태그를 그대로 사용하기 때문에 익숙하며, HTML 마크업과 자바스크립트 로직을 같이 구현할 수 있다.
자바스크립트 문법을 이용해서 HTML을 생성할 수도 있으며, 기존의 `DOM + Event` 작업보다 간편하게 UI를 구성할 수 있다.

<br/>

### 선언형 프로그래밍
#### 선언형 프로그래밍 (Declarative Programming)
원하는 결과를 묘사하는 방식으로 코드를 작성하는 프로그래밍.
'데이터를 어떻게 조작해야 하는지'가 아니라, '원하는 데이터는 무엇인지'에 집중한다.
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6, 8, 10]
```
- 짝수를 어떻게 필터링해야 하는 지가 아닌, 짝수를 필터링한 결과를 얻는 것에 초점을 맞춘다.
- 전체적인 가독성과 추상화 수준을 높여, 개발자가 문제의 본질에 집중할 수 있도록 돕는다.
- 재사용성이 높고, 병렬 처리가 유리한 특징을 갖는다.

#### 명령형 프로그래밍 (Imperative Programming)
'코드가 어떻게 동작해야 하는지'를 중심으로 하여, 상태와 제어 흐름을 명시적으로 관리하는 방식을 코드로 작성함.
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = [];
for (let i = 0; i < numbers.length; i++) {
	const num = numbers[i];
	if (num % 2 === 0) {
		evenNumbers.push(num);
	}
}
console.log(evenNumbers); // [2, 4, 6, 8, 10]
```
- `numbers 배열의 길이만큼 반복`, `만약 num이 2로 나누어떨어진다면...` 등 문제를 해결하는 과정을 작성하는 것에 초점을 맞춘다.
- 코드의 가독성이 저하되거나, 재사용성이 낮아질 수 있다.

#### 리액트의 선언형 UI
다음 `Login` 컴포넌트는 선언형 UI로 작성됨.
```JSX
const Login = () => {
	return (
		<article>
			<p>ID</p>
			<input name="id", type="text"/>
			<p>PASSWORD</p>
			<input name="password", type="password"/>
		</article>
	)
}
```
- 현재 본인이 원하는 LoginForm의 모습(결과값)만 return 하고 있으며, 어떻게 UI를 화면에 보이게 할 건지는 작성되어 있지 않음.
- 즉, UI를 다루는 부분은 리액트에게 위임하고, 개발자는 결과에만 초점을 맞춰 개발할 수 있음.
	- React는 `render` 함수를 이용하여 (`ReactDOM.render(...)`) 화면에 출력한다.

---
**Reference**

[React란, 프론트엔드 대표 개발 도구 리액트의 특징과 이점](https://www.elancer.co.kr/blog/view?seq=167)

[React란 무엇인가?](https://hymndev.tistory.com/45)

[React란](https://deku.posstree.com/ko/react/create-react-app/react/#%EA%B0%80%EC%83%81-%EB%8F%94)

[React에서의 가상돔 개념](https://velog.io/@mollog/React%EC%97%90%EC%84%9C%EC%9D%98-%EA%B0%80%EC%83%81%EB%8F%94-%EA%B0%9C%EB%85%90)

[[JS] 데이터 바인딩 이해하기(단방향, 양방향 데이터 바인딩](https://ko.legacy.reactjs.org/c158617ed7cc0eac8f58330e49e48224/granular-dom-updates.gif)

[선언형 프로그래밍으로 이해하기 쉬운 코드 작성하기](https://yozm.wishket.com/magazine/detail/2083/)
