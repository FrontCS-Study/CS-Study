## 캐시와 토큰(JWT)

- [캐시](#--)
  * [캐시(Cache)](#---cache-)
  * [캐싱(Caching)](#---caching-)
  * [캐시 사용하는 이유](#----------)
  * [데이터 지역성 원리](#----------)
  * [+a) 캐시 히트와 캐시 미스](#-a--------------)
- [토큰](#--)
  * [토큰(Token)](#---token-)
  * [토큰 인증](#-----)
  * [세션 VS 토큰](#---vs---)
  * [JWT(Json Web Token)](#jwt-json-web-token-)
  * [JWT 구조](#jwt---)
  * [JWT 인증 과정](#jwt------)
  * [JWT 장점](#jwt---)
  * [JWT 단점](#jwt---)
  * [+a) JWT의 Access Token / Refresh Token](#-a--jwt--access-token---refresh-token)
  * [+a) Access / Refresh Token 재발급 원리](#access---refresh-token-------)



### 캐시

---

#### 캐시(Cache)

- 프랑스어로 ’숨기다’ 라는 뜻을 가지는 단어인 ‘cacher’ 에서 파생된 단어로, 물건을 일시적으로 저장, 보관하기 위해 사용하는 곳

- 기술적으로 자주 필요한 데이터나 값의 **복사본**을 일시적으로 저장, 보관하기 위해 사용하는 곳을 의미한다.

#### 캐싱(Caching)

- 캐시를 사용하는 것, Cache + ing 합성어

- 캐시에 데이터나 계산된 결과 값의 복사본을 저장해 전체적인 **처리 속도를 향상** 시키는 기법이다.
- 가져오는데 비용이 드는 데이터를 한번에 가져온 뒤 사용자의 컴퓨터 또는 중간 역할을 하는 서버에 임시 저장하는 것

---

#### 캐시 사용하는 이유

- **CPU와 RAM 성능 차이 때문이다.**

  - 메모리는 속도보다 용량을 늘리는 것을 주 목표로 발전해 오면서, 이 차이는 시간이 지남에 따라 더 크게 차이가 나게 됨.

  - CPU는 데이터 처리를 위해 메모리와 데이터를 주고받는 구조

  - 메모리가 CPU의 데이터 처리 속도를 쫓아가지 못하게 되면서 CPU가 메모리를 기다려야 하는 병목 현상이 생긴다.
  
    ⇒ **병목 현상을 완화하기 위해** 캐시를 사용한다.

- 사용하는 경우
  - 데이터에 직접적으로 접근하는데 걸리는 시간이 오래 걸릴 때
  - 반복적으로 동일한 결과를 돌려주는 경우(이미지나 썸네일 등)
  - ngnix 등으로 fe 빌드 파일을 배포할 때 캐시 컨트롤 사용하면 초기 로딩 속도 최적화를 할 수 있다.
    - 서버에 캐시 파일 리소스 유효기간을 설정, 기간 내 같은 리소스 요청시 캐시된 리소스 사용
    - 캐시 유효기간이 지나면 파일이 변동 됐는지 서버에 재검증 확인
    - 변경되지 않은 경우 캐시된 파일을 이용하여 load, 변경됐다면 최신 파일을 다운로드하고 load
- 단, 복사본과 원본이 달라지는 경우가 생길 수 있으니 **일관성 유지에 유의**해야 한다.

---

#### 데이터 지역성 원리

> 재사용할 가능성이 클 지는 어떻게 알 수 있을까?

- 데이터 지역성의 원리란 데이터 접근이 시간적 혹은 공간적으로 가깝게 일어나는 것을 의미한다.
- 시간지역성 : 한번 참조된 변수는 잠시 후 또 참조 될 가능성이 높다.
- 공간지역성 : 어떤 데이터에 접근할 때, 그 데이터 근처에 있는 다른 데이터도 참조될 가능성이 높다.

---

#### +a) 캐시 히트와 캐시 미스

- 캐시 히트 : 캐시 메모리가 해당 데이터를 가지고 있다

- 캐시 미스 : 캐시에 해당 데이터가 없어서 메인 메모리에서 가져와야 한다

---

**참고**

- [[10분 테코톡\] 🏖 파피의 Caching(캐싱)](https://www.youtube.com/watch?v=JBFT4KyEvoY&t=314s)
- [프론트엔드 성능최적화(6)]([]())

---


<br><br><br>


### 토큰

---

> **인증(Authentication)** : 특정 서비스에 일정 권한이 주어진 사용자임을 확인하는 절차
>
> **인가(Authorization)** : 인증을 받은 사용자가 맞는지 확인하는 절차

#### 토큰(Token)

- 서버가, 각각의 클라이언트를 누군지 정확히 구별할 수 있도록, 유니크한 정보를 담은 **암호화 데이터**
- 사용자 구분 및 정보 유출 방지을 목적으로 사용한다.

#### 토큰 인증

- 토큰 기반 인증 시스템은 클라이언트가 서버에 접속을 하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 **토큰을 부여**한다.
- 토큰은 **유일**하며 토큰을 발급 받은 클라이언트는 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다. 그러면 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 **일치 여부를 체크**하여 **인증 과정을 처리**하게 된다.

---

#### 세션 VS 토큰

- 세션은 페이지 요청에 따라 서버에서 세션ID를 DB에서 찾는다. **조회하는 과정**이 필요하기 때문에 사용자가 증가함에 따라 **성능의 문제**를 일으킬 수 있으며 확장성이 어렵다는 단점을 지닌다.
- 토큰은 세션과 다르게 유저를 인증하는데 필요한 정보를 토큰에 저장한다. 페이지를 요청하면 서버는 해당 토큰이 유효한지만 검증하면되기 때문에 유저 인증을 위한 **DB를 거치지 않는다**
- 토큰은 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.
- **사용 예시로 이해하기**
  - 세션은 로그인된 여러 디바이스를 확인하고 특정 디바이스에서 강제 로그아웃 할 수 있다. 넷플릭스처럼 계정 공유 숫자를 제한 할 수 있다.
  - 토큰이 만료되기 전까지는 유효하기 때문에 강제 로그아웃 시킬 수 없다.
  - 토큰은 유효한지만 확인하기 때문에 같은 id 유저가 동시 접속이 가능, 하지만 세션 사용시 이미 접속한 기록이 있기 때문에 같은 id 접속시 막을 수 있다.

------

#### JWT(Json Web Token)

- 인증에 필요한 정보들을 암호화시킨 JSON 토큰
- **JWT 기반 인증**은 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식이다.
- JWT는 JSON 데이터를 **Base64 URL-safe Encode**를 통해 인코딩하여 직렬화한 것이며, 토큰 내부에는 위변조 방지를 위해 개인키를 통한 **전자서명**도 들어있다.
- 사용자가 JWT 를 서버로 전송하면 서버는 서명을 검증하는 과정을 거치게 되며 검증이 완료되면 요청한 응답을 돌려준다.

------

#### JWT 구조

<div align="center">
  <img src="https://github.com/FrontCS-Study/CS-Study/assets/83412032/c0ceaccc-73fc-4a16-b1a7-90046a0f84f6" alt="JWT구조" width="70%" align="center"/>
</div>
<br>

- 헤더(Header) : 타입(토큰 유형)과 해시 알고리즘의 종류
- 내용(Payload) : key-value 형식으로 시스템에서 **사용될 정보에 대한 내용**으로 서버에서 첨부한 사용자 권한 정보와 데이터
- 서명(Signature) : Header, Payload를 Base64 URL-safe Encode를 한 이후 Header에 명시된 해시함수를 적용하고, 서버가 갖고 있는 유일한 key 값으로 서명한 전자서명이 담겨있다.
  - Header와 Payload는 단순히 인코딩된 값으로 제 3자가 복호화 및 조작할 수 있지만, Signature는 서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화할 수 없다.

⇒ 복호화 하면 사용자의 데이터를 담은 Payload 부분이 그대로 노출되기 때문에 민감 정보는 넣지 말아야 하며, Signature를 통해 토큰의 위변조 여부를 확인하는 **위조 방지** 하는데 사용된다.

------

#### JWT 인증 과정

<div align="center">
  <img src="https://github.com/FrontCS-Study/CS-Study/assets/83412032/ee817a09-4d25-47bd-8465-94bc1fd59027" alt="JWT 인증 과정" width="70%" align="center"/>
</div>
<br>

1. 사용자가 ID, PW를 입력하여 서버에 로그인 인증을 요청한다.
2. 서버에서 클라이언트로부터 인증 요청을 받으면, Header, PayLoad, Signature를 정의한다. Hedaer, PayLoad, Signature를 각각 Base64로 한 번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.
3. 클라이언트는 서버로부터 받은 JWT를 쿠키나 스토리지에 저장한다.
4. API를 서버에 요청할때 Authorization header에 Access Token을 담아서 보낸다.
5. 서버는 클라이언트가 Header에 담아서 보낸 JWT가 내 서버에서 발행한 토큰인지 일치 여부를 확인하고, 일치한다면 인증을 통과시켜주고 아니라면 통과시키지 않으면 된다. 인증이 통과되면 PayLoad에 들어있는 유저의 정보들을 조회해서 클라이언트에 돌려준다.
6. 클라이언트가 서버에 요청을 했는데, 만일 액세스 토큰의 시간이 만료되면 클라이언트는 리프래시 토큰을 이용해서 서버로부터 새로운 엑세스 토큰을 발급 받는다.

------

#### JWT 장점

- Header와 Payload를 가지고 Signature를 생성하므로 **데이터 위변조를 막을 수 있다.**
- 인증 정보에 대한 **별도의 저장소가 필요없다.**
- 모바일 어플리케이션 환경에서도 잘 동작한다.(모바일은 세션 사용 불가능)
- DB조회를 없이 user식별 정보를 얻을 수 있다.
  - payload에 유저 이름과 유저 등급을 같이 두고 보내면, 서버에서는 유저 이름을 가지고 DB를 조회해서 유저 등급을 얻지 않아도 바로 원하는 정보를 취할 수 있다.

#### JWT 단점

- 토큰 길이 : 토큰의 Payload에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다.
- Payload 인코딩 : payload 자체는 암호화 된 것이 아니라 BASE64로 인코딩 된 것이기 때문에, 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, payload에 중요 데이터를 넣지 않아야 한다.
- Store Token : stateless 특징을 가지기 때문에, 토큰은 클라이언트 측에서 관리하고 저장한다. 때문에 토큰 자체를 탈취 당하면 대처하기가 어렵게 된다. (→ 유효 시간을 부여하는 형식으로 대처)

------

#### +a) JWT의 Access Token / Refresh Token

> 제 3자의 토큰 탈취에 대응하고자 토큰에 유효 시간을 부여했으나 토큰 유효 기간이 짧으면 사용자는 로그인을 자주 해야한다는 불편한 점이 있다. 
<br> 위험성을 방지하고 사용자 불편성을 줄이고자 Access Token, Refresh Token으로 이중으로 나누어 인증한다.

- **Access Token** : 실제로 유저의 정보가 담긴 **클라이언트가 갖고 있는 토큰**으로, 클라이언트에서 요청이 오면 서버에서 해당 토큰에 있는 정보를 활용하여 사용자 정보에 맞게 응답을 진행

- **Refresh Token** : 새로운 Access Token을 발급해주기 위해 사용하는 토큰으로 짧은 수명을 가지는 Access Token에게 새로운 토큰을 발급해주기 위해 사용. 해당 토큰은 보통 **데이터베이스**에 유저 정보와 같이 기록.

- **Access Token**은 **접근**에 관여하는 토큰, **Refresh Token**은 **재발급**에 관여하는 토큰의 역할로 사용되는 JWT이다.

- ##### Access / Refresh Token 재발급 원리

  1. 로그인 같은 과정을 하면 Access Token과 Refresh Token을 모두 발급한다.
     - Refresh Token만 서버측의 DB에 저장하며, Refresh Token과 Access Token을 쿠키 혹은 웹스토리지에 저장한다.

  2. 사용자가 인증이 필요한 API에 접근하고자 하면, 가장 먼저 토큰을 검사한다.

     - case1 : access token과 refresh token 모두가 만료된 경우 **→** 에러 발생 (재 로그인하여 둘다 새로 발급)

     - case2 : access token은 만료됐지만, refresh token은 유효한 경우 **→** refresh token을 검증하여 access token 재발급

     - case3 : access token은 유효하지만, refresh token은 만료된 경우 **→** access token을 검증하여 refresh token 재발급

     - case4 : access token과 refresh token 모두가 유효한 경우 **→** 정상 처리

  3. 로그아웃을 하면 Access Token과 Refresh Token을 모두 만료시킨다.

------

**참고**

- [JWT 토큰 인증 이란?](https://inpa.tistory.com/entry/WEB-📚-JWTjson-web-token-란-💯-정리#token_인증)
- [Access Token & Refresh Token 원리](https://inpa.tistory.com/entry/WEB-📚-Access-Token-Refresh-Token-원리-feat-JWT)

