[TOC]

## 배열

> *" 자바스크립트의 배열은 자료구조의 배열과 다르다. "*

- **자료구조의 배열**

  동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다.  
  즉, 배열의 요소는 하나의 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다.   
  이러한 배열을 **밀집 배열(dense array)** 이라 한다.

- **자바스크립트의 배열**

  배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다.   
  배열의 요소가 연속적으로 이어져 있지 않는 배열을 **희소 배열(sparse array)** 이라 한다.  
  자바스크립트의 배열은 일반적인 배열의 동작을 흉내낸 특수한 객체이다.

<br>

> 💡 **자료구조의 배열 VS 자바스크립트의 배열**
>
> 일반적인 배열은 인덱스로 배열 요소에 빠르게 접근할 수 있다.   
> 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않다.
>
> 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우,   
> 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없는 구조적인 단점을 갖는다.  
> 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.

<br>

### 배열 생성자


```javascript
const arr = new Array(1, 2, 3);

const arr2 = new Array(20); // 인수 하나만 넘겨줄때는 그 인수가 배열길이
arr2.length; // 20
```

<br>

### 배열의 메서드 종류

배열에는 원본 배열을 직접 변경하는 메서드가 있고, 새로운 배열을 생성하여 반환하는 메서드가 있다. 

원본 배열을 직접 변경하는 메서드는 외부 상태를 직접 변경하는 부수효과가 있으므로 사용할 때 주의해야 한다.  
가급적 원본 배열을 직접 변경하지 않는 메서드를 사용하는 편이 좋다.

- **Array.isArray(arg) : boolean**

  주어진 인수가 배열이면 true, 배열이 아니면 false를 반환한다.

- **Array.from**

  ES6에서 새롭게 도입되었으며, 특정 객체를 변환하여 새로운 배열을 생성한다.   
  변환 할 수 있는 특정한 객체는 다음과 같다.  

  - **유사배열 객체(array-like objects)** : length 프로퍼티와 인덱스 된 요소를 가지고 있는 객체  

  - **이터러블 객체 (iterable objects)** : Map과 Set 객체 및 문자열과 같이 해당 요소를 개별적으로 선택할 수 있는 객체

  ```javascript
  // 문자열은 이터러블이다.
  const arr1 = Array.from('Hello'); 	// [ 'H', 'e', 'l', 'l', 'o' ]
  
  // 유사 배열 객체를 새로운 배열을 변환하여 반환한다.
  const arr2 = Array.from({ length: 2, 0: 'a', 1: 'b' }); 	// [ 'a', 'b' ]
  
  // Array.from의 두번째 매개변수에게 배열의 모든 요소에 대해 호출할 함수를 전달할 수 있다.
  // 이 함수는 첫번째 매개변수에게 전달된 인수로 생성된 배열의 모든 요소를 인수로 전달받아 호출된다.
  const arr3 = Array.from({ length: 5 }, function (v, i) { return i; });  	// [ 0, 1, 2, 3, 4 ]
  ```

- **Array.of**

  ES6에서 새롭게 도입된 Array.of 메서드는 전달된 인수를 요소로 갖는 배열을 생성한다.  
  Array.of는 Array 생성자 함수와 다르게 전달된 **인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성**한다.  

  ```javascript
  const arr1 = Array.of(1, 2, 3); 	// [1, 2, 3]
  const arr2 = Array.of('string'); 	// 'string'
  ```

<br>

- **프로토타입 메서드**

  |      메서드      | 설명                                                         |
  | :--------------: | ------------------------------------------------------------ |
  |      push()      | 하나 이상의 요소를 배열의 가장 마지막에 추가하고, 배열의 총 길이를 반환함. |
  |      pop()       | 배열의 가장 마지막 요소를 제거하고, 그 제거된 요소를 반환함. |
  |     shift()      | 배열의 가장 첫 요소를 제거하고, 그 제거된 요소를 반환함.     |
  |    unshift()     | 하나 이상의 요소를 배열의 가장 앞에 추가하고, 배열의 총 길이를 반환함. |
  |    reverse()     | 배열 요소의 순서를 전부 반대로 교체함.                       |
  |      sort()      | 해당 배열의 배열 요소들을 알파벳 순서에 따라 정렬함.         |
  |     splice()     | 기존의 배열 요소를 제거하거나 새로운 배열 요소를 추가하여 배열의 내용을 변경함. |
  |   copyWithin()   | 해당 배열에서 일련의 요소들을 복사하여, 명시된 위치의 요소들을 교체함. |
  |      fill()      | 시작 인덱스부터 종료 인덱스 바로 앞까지의 모든 배열 요소를 특정 값으로 교체함. |
  |      join()      | 배열의 모든 요소를 하나의 문자열로 반환함.                   |
  |     slice()      | 전달받은 시작 인덱스부터 종료 인덱스 바로 앞까지의 모든 배열 요소를 추출하여 만든 새로운 배열을 반환함. |
  |      push()      | 하나 이상의 요소를 배열의 가장 마지막에 추가하고, 배열의 총 길이를 반환함. |
  |      pop()       | 배열의 가장 마지막 요소를 제거하고, 그 제거된 요소를 반환함. |
  |     shift()      | 배열의 가장 첫 요소를 제거하고, 그 제거된 요소를 반환함.     |
  |    unshift()     | 하나 이상의 요소를 배열의 가장 앞에 추가하고, 배열의 총 길이를 반환함. |
  |    reverse()     | 배열 요소의 순서를 전부 반대로 교체함.                       |
  |      sort()      | 해당 배열의 배열 요소들을 알파벳 순서에 따라 정렬함.         |
  |     splice()     | 기존의 배열 요소를 제거하거나 새로운 배열 요소를 추가하여 배열의 내용을 변경함. <br />추가, 교체, 삭제 기능으로 사용 가능 |
  |   copyWithin()   | 해당 배열에서 일련의 요소들을 복사하여, 명시된 위치의 요소들을 교체함. |
  |      fill()      | 시작 인덱스부터 종료 인덱스 바로 앞까지의 모든 배열 요소를 특정 값으로 교체함. |
  |      join()      | 배열의 모든 요소를 하나의 문자열로 반환함.                   |
  |     slice()      | 전달받은 시작 인덱스부터 종료 인덱스 바로 앞까지의 모든 배열 요소를 추출하여 만든 새로운 배열을 반환함. |
  |     concat()     | 해당 배열의 뒤에 인수로 전달받은 배열을 합쳐서 만든 새로운 배열을 반환함. |
  |    toString()    | 해당 배열의 모든 요소를 하나의 문자열로 반환함.              |
  | toLocaleString() | 해당 배열의 모든 요소를 하나의 문자열로 반환함.              |
  |    indexOf()     | 전달받은 값과 동일한 배열 요소가 처음으로 등장하는 위치의 인덱스를 반환함. |
  |  lastIndexOf()   | 전달받은 값과 동일한 배열 요소가 마지막으로 등장하는 위치의 인덱스를 반환함. |
  |    forEach()     | 해당 배열의 모든 요소에 대하여 반복적으로 명시된 콜백 함수를 실행함. |

<br>

> **💡 push vs concat 차이**
>
>
> - push 메서드는 원본 배열을 직접 변경하지만, concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.
>
> - push 메서드는 배열을 그대로 원본 배열의 마지막 요소로 추가하지만, concat 메서드는 배열을 해체하여 새로운 배열의 마지막 요소로 추가한다.  
>
>   ```java
>   const arr1 = [1, 2];
>   // 인수로 전달받은 배열을 그대로 원본 배열의 마지막 요소로 추가한다
>   arr1.push([3, 4]);
>   console.log(arr1); // [1, 2, [3, 4]]
>   
>   const arr2 = [1, 2];
>   // 인수로 전달받은 배열을 해체하여 새로운 배열의 마지막 요소로 추가한다
>   const result = arr2.concat([3, 4]);
>   console.log(result); // [1, 2, 3, 4]
>   ```
>
> - push 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 push 메서드보다는 ES6의 spread 문법(전개연산자)을 사용하는 편이 좋다.
>
>   ```javascript
>   const arr = [1, 2];
>   
>   // ES6 spread 문법
>   const newArr = [...arr, 3];
>   console.log(newArr); // [1, 2, 3]
>   ```
>

<br>

> **💡 slice vs splie 차이**
>
>
> - slice는 배열의 일부분을 복사해서 반환하며 원본을 훼손하지 않는다.
>
> - splice는 배열에서 요소를 제거하고 제거한 위치에 다른 요소를 추가하며 원본을 훼손한다.
>
> ```javascript
> const items = [1, 2, 3, 4];
> 
> // items[1]부터 2개의 요소를 제거하고 제거된 요소를 배열로 반환
> const res1 = items1.splice(1, 2);
> 
> // 원본 배열이 변경된다.
> console.log(items1); // [ 1, 4 ]
> // 제거한 요소가 배열로 반환된다.
> console.log(res1);   // [ 2, 3 ]
> 
> // -------------------------------------------
> 
> const items2 = [1, 2, 3, 4];
> 
> // items[0]부터 items[1] 이전(items[1] 미포함)까지 반환
> let res = items.slice(0, 1);
> console.log(res);  // [ 1 ]
> 
> res = items.slice();
> console.log(res);  // [ 1, 2, 3, 4 ]
> ```
>

<br>

## 고차 함수

고차 함수란, **함수를 파라미터로 전달받거나 연산의 결과로 반환해주는 메서드**를 일컫는다. 

자바스크립트의 함수는 일급 객체이므로 값처럼 인자로 전달할 수 있으며 반환할 수도 있다. 

고차 함수는 외부 상태 변경이나 가변(mutable) 데이터를 피하고 **불변성(Immutability)을 지향**하는 **함수형 프로그래밍에 기반**을 두고 있다.

> 🔍 **함수형 프로그래밍이란?**
> 함수형 프로그래밍은 함수를 다른 함수의 파라미터로 넘길 수도 있고 반환(return) 값으로 함수를 받을 수도 있는 프로그래밍 형태를 말한다. 함수형 프로그래밍에서, 개발자는 함수라는 용어 하에서 생각하고 코딩하게 된다.

### 고차 함수 종류

|   메서드    | 설명                                                         |
| :---------: | ------------------------------------------------------------ |
|  forEach()  | for문을 대체하는 고차 함수.<br />반복문을 추상화하여 구현된 메서드이고 내부에서 주어진 배열을 순회하면서 연산을 수행 |
|    map()    | forEach 같이 순회하면서, 콜백함수에서의 실행결과를 리턴한 값으로 이루어진 배열을 만들어 반환 |
|   find()    | 찾고자 하는 값을 그대로 반환한다. <br />주어진 배열을 순회하면서 콜백 함수 실행의 반환값이 true에 해당하는 첫번째 요소를 반환 |
| findIndex() | 배열 메서드 `indexOf()` 의 콜백함수 버전. 고차함수 find()의 리턴값이 인덱스인 버전. |
|  filter()   | 주어진 배열을 순회하면서 콜백 함수의 반환값이 true에 해당하는 요소로만 구성된 새로운 배열을 생성하여 반환. |
|  reduce()   | 콜백 함수의 실행된 반환값(initialValue)을 전달 받아 연산의 결과값이 반환.<br />첫 번째 인자(accumulator)서부터 시작해서 배열 값인 두 번째 인자(currentvalue) 을 순회하며 `accumulator+=currentvalue`을 실행. |
|   sort()    | 배열 정렬. 단, 복사본이 아닌 원 배열이 정렬됨.<br />콜백 함수를 통해 배열의 원소들을 어느 기준으로 정렬할지 지정해야함 |
|   some()    | 배열 메서드인 `include()`의 콜백 함수 버전. <br />include는 값이 있냐에 따른 bool이면, some은 함수의 로직에 따른 bool.<br />배열의 요소들을 주어진 함수(조건)을 통과하는데 한개라도 통과되면 true, 아닐때에는 false를 출력. |
|   every()   | some() 의 반대 버전. <br />배열안의 모든 요소가 주어진 함수(조건)을 모두 통과하면 true, 한 요소라도 통과하지 못하면 false를 출력. |

> **💡 forEach와 map의 차이**
>
> 두 메서드 모두 배열을 순회하는 것은 동일하지만
>
> forEach()의 경우 각 요소를 참조한 연산이 이루어지고,  
> map()의 경우엔 각 요소를 다른 값으로 맵핑한 새로운 배열이 반환되는 점에 차이가 있다.
>
> 정리하면 forEach()는 for문을 대체하여 사용하고 map()은 연산의 결과로 새로운 배열을 생성하고자 할 때 사용된다.


---

**참고**

[자바스크립트 배열은 배열이 아니다](https://poiemaweb.com/js-array-is-not-arrray)

[[JS] 📚 자바스크립트 Array 메서드 💯 총정리](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-Array-%EB%A9%94%EC%86%8C%EB%93%9C-%E2%9C%8F%EF%B8%8F-%EC%A0%95%EB%A6%AC#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_array_%EB%A9%94%EC%86%8C%EB%93%9C)

[📚 JavaScript 배열 고차 함수 총정리](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B0%B0%EC%97%B4-%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98-%EC%B4%9D%EC%A0%95%EB%A6%AC-%F0%9F%92%AF-mapfilterfindreducesortsomeevery#.every)
