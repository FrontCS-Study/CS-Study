[TOC]

## 배열

***" 자바스크립트의 배열은 자료구조의 배열과 다르다. "***

- 자료구조의 배열

  동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다.  
  즉, 배열의 요소는 하나의 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다.   
  이러한 배열을 **밀집 배열(dense array)**이라 한다.

- 자바스크립트의 배열

  배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며,  
  연속적으로 이어져 있지 않을 수도 있다.  
  배열의 요소가 연속적으로 이어져 있지 않는 배열을 **희소 배열(sparse array)**이라 한다.  
  자바스크립트의 배열은 일반적인 배열의 동작을 흉내낸 특수한 객체이다.

> 💡 **자료구조의 배열 VS 자바스크립트의 배열**
>
> 일반적인 배열은 인덱스로 배열 요소에 빠르게 접근할 수 있다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않다.
>
> 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우, 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없는 구조적인 단점을 갖는다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.

<br>

### 배열 생성자


```javascript
const arr = new Array(1, 2, 3);

const arr2 = new Array(20); // 인수 하나만 넘겨줄때는 그 인수가 배열길이
arr2.length; // 20
```

<br>

### 배열의 메서드 종류

배열에는 원본 배열을 직접 변경하는 메서드가 있고, 새로운 배열을 생성하여 반환하는 메서드가 있다. 

원본 배열을 직접 변경하는 메서드는 외부 상태를 직접 변경하는 부수효과가 있으므로 사용할 때 주의해야 한다.  
가급적 원본 배열을 직접 변경하지 않는 메서드를 사용하는 편이 좋다.

- **Array.isArray(arg) : boolean**

  주어진 인수가 배열이면 true, 배열이 아니면 false를 반환한다.

- **Array.from**

  ES6에서 새롭게 도입되었으며, 특정 객체를 변환하여 새로운 배열을 생성한다.   
  변환 할 수 있는 특정한 객체는 다음과 같다.  

  - **유사배열 객체(array-like objects)** : length 프로퍼티와 인덱스 된 요소를 가지고 있는 객체  

  - **이터러블 객체 (iterable objects)** : Map과 Set 객체 및 문자열과 같이 해당 요소를 개별적으로 선택할 수 있는 객체

  ```javascript
  // 문자열은 이터러블이다.
  const arr1 = Array.from('Hello'); 	// [ 'H', 'e', 'l', 'l', 'o' ]
  
  // 유사 배열 객체를 새로운 배열을 변환하여 반환한다.
  const arr2 = Array.from({ length: 2, 0: 'a', 1: 'b' }); 	// [ 'a', 'b' ]
  
  // Array.from의 두번째 매개변수에게 배열의 모든 요소에 대해 호출할 함수를 전달할 수 있다.
  // 이 함수는 첫번째 매개변수에게 전달된 인수로 생성된 배열의 모든 요소를 인수로 전달받아 호출된다.
  const arr3 = Array.from({ length: 5 }, function (v, i) { return i; });  	// [ 0, 1, 2, 3, 4 ]
  ```

- **Array.of**

  ES6에서 새롭게 도입된 Array.of 메서드는 전달된 인수를 요소로 갖는 배열을 생성한다.  
  Array.of는 Array 생성자 함수와 다르게 전달된 **인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성**한다.  

  ```javascript
  const arr1 = Array.of(1, 2, 3); 	// [1, 2, 3]
  const arr2 = Array.of('string'); 	// 'string'
  ```

<br>

<details>
  <summary><b>그 외 Array 프로토타입 메서드들</b></summary>

| 프로토타입<br />메서드 | 설명                                                         |
| :--------------------: | ------------------------------------------------------------ |
|         push()         | 하나 이상의 요소를 배열의 가장 마지막에 추가하고, 배열의 총 길이를 반환함. |
|         pop()          | 배열의 가장 마지막 요소를 제거하고, 그 제거된 요소를 반환함. |
|        shift()         | 배열의 가장 첫 요소를 제거하고, 그 제거된 요소를 반환함.     |
|       unshift()        | 하나 이상의 요소를 배열의 가장 앞에 추가하고, 배열의 총 길이를 반환함. |
|       reverse()        | 배열 요소의 순서를 전부 반대로 교체함.                       |
|         sort()         | 해당 배열의 배열 요소들을 알파벳 순서에 따라 정렬함.         |
|        splice()        | 기존의 배열 요소를 제거하거나 새로운 배열 요소를 추가하여 배열의 내용을 변경함. |
|      copyWithin()      | 해당 배열에서 일련의 요소들을 복사하여, 명시된 위치의 요소들을 교체함. |
|         fill()         | 시작 인덱스부터 종료 인덱스 바로 앞까지의 모든 배열 요소를 특정 값으로 교체함. |
|         join()         | 배열의 모든 요소를 하나의 문자열로 반환함.                   |
|        slice()         | 전달받은 시작 인덱스부터 종료 인덱스 바로 앞까지의 모든 배열 요소를 추출하여 만든 새로운 배열을 반환함. |
|         push()         | 하나 이상의 요소를 배열의 가장 마지막에 추가하고, 배열의 총 길이를 반환함. |
|         pop()          | 배열의 가장 마지막 요소를 제거하고, 그 제거된 요소를 반환함. |
|        shift()         | 배열의 가장 첫 요소를 제거하고, 그 제거된 요소를 반환함.     |
|       unshift()        | 하나 이상의 요소를 배열의 가장 앞에 추가하고, 배열의 총 길이를 반환함. |
|       reverse()        | 배열 요소의 순서를 전부 반대로 교체함.                       |
|         sort()         | 해당 배열의 배열 요소들을 알파벳 순서에 따라 정렬함.         |
|        splice()        | 기존의 배열 요소를 제거하거나 새로운 배열 요소를 추가하여 배열의 내용을 변경함. <br />추가, 교체, 삭제 기능으로 사용 가능 |
|      copyWithin()      | 해당 배열에서 일련의 요소들을 복사하여, 명시된 위치의 요소들을 교체함. |
|         fill()         | 시작 인덱스부터 종료 인덱스 바로 앞까지의 모든 배열 요소를 특정 값으로 교체함. |
|         join()         | 배열의 모든 요소를 하나의 문자열로 반환함.                   |
|        slice()         | 전달받은 시작 인덱스부터 종료 인덱스 바로 앞까지의 모든 배열 요소를 추출하여 만든 새로운 배열을 반환함. |
|        concat()        | 해당 배열의 뒤에 인수로 전달받은 배열을 합쳐서 만든 새로운 배열을 반환함. |
|       toString()       | 해당 배열의 모든 요소를 하나의 문자열로 반환함.              |
|    toLocaleString()    | 해당 배열의 모든 요소를 하나의 문자열로 반환함.              |
|       indexOf()        | 전달받은 값과 동일한 배열 요소가 처음으로 등장하는 위치의 인덱스를 반환함. |
|     lastIndexOf()      | 전달받은 값과 동일한 배열 요소가 마지막으로 등장하는 위치의 인덱스를 반환함. |
|       forEach()        | 해당 배열의 모든 요소에 대하여 반복적으로 명시된 콜백 함수를 실행함. |

</details>

<details>
  <summary><b>💡 push vs concat 차이</b></summary>

- push 메서드는 원본 배열을 직접 변경하지만, concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.

- push 메서드는 배열을 그대로 원본 배열의 마지막 요소로 추가하지만, concat 메서드는 배열을 해체하여 새로운 배열의 마지막 요소로 추가한다.  

  ```java
  const arr1 = [1, 2];
  // 인수로 전달받은 배열을 그대로 원본 배열의 마지막 요소로 추가한다
  arr1.push([3, 4]);
  console.log(arr1); // [1, 2, [3, 4]]
  
  const arr2 = [1, 2];
  // 인수로 전달받은 배열을 해체하여 새로운 배열의 마지막 요소로 추가한다
  const result = arr2.concat([3, 4]);
  console.log(result); // [1, 2, 3, 4]
  ```

- push 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 push 메서드보다는 ES6의 spread 문법(전개연산자)을 사용하는 편이 좋다.

  ```javascript
  const arr = [1, 2];
  
  // ES6 spread 문법
  const newArr = [...arr, 3];
  console.log(newArr); // [1, 2, 3]
  ```

</details>

<details>
  <summary><b>💡 slice vs splie 차이</b></summary>

- slice는 배열의 일부분을 복사해서 반환하며 원본을 훼손하지 않는다.

- splice는 배열에서 요소를 제거하고 제거한 위치에 다른 요소를 추가하며 원본을 훼손한다.

```javascript
const items = [1, 2, 3, 4];

// items[1]부터 2개의 요소를 제거하고 제거된 요소를 배열로 반환
const res1 = items1.splice(1, 2);

// 원본 배열이 변경된다.
console.log(items1); // [ 1, 4 ]
// 제거한 요소가 배열로 반환된다.
console.log(res1);   // [ 2, 3 ]

// -------------------------------------------

const items2 = [1, 2, 3, 4];

// items[0]부터 items[1] 이전(items[1] 미포함)까지 반환
let res = items.slice(0, 1);
console.log(res);  // [ 1 ]

res = items.slice();
console.log(res);  // [ 1, 2, 3, 4 ]
```

</details>

### 고차 함수

고차 함수란, **함수를 파라미터로 전달받거나 연산의 결과로 반환해주는 메서드**를 일컫는다. 

자바스크립트의 함수는 일급 객체이므로 값처럼 인자로 전달할 수 있으며 반환할 수도 있다.  
고차 함수는 외부 상태 변경이나 가변(mutable) 데이터를 피하고 **불변성(Immutability)을 지향**하는 **함수형 프로그래밍에 기반**을 두고 있다.

> 🔍 **함수형 프로그래밍이란?**
> 함수형 프로그래밍은 함수를 다른 함수의 파라미터로 넘길 수도 있고 반환(return) 값으로 함수를 받을 수도 있는 프로그래밍 형태를 말한다. 함수형 프로그래밍에서, 개발자는 함수라는 용어 하에서 생각하고 코딩하게 된다.

### 고차 함수 종류

|   메서드    | 설명                                                         |
| :---------: | ------------------------------------------------------------ |
|  forEach()  | for문을 대체하는 고차 함수.<br />반복문을 추상화하여 구현된 메서드이고 내부에서 주어진 배열을 순회하면서 연산을 수행 |
|    map()    | forEach 같이 순회하면서, 콜백함수에서의 실행결과를 리턴한 값으로 이루어진 배열을 만들어 반환 |
|   find()    | 찾고자 하는 값을 그대로 반환한다. <br />주어진 배열을 순회하면서 콜백 함수 실행의 반환값이 true에 해당하는 첫번째 요소를 반환 |
| findIndex() | 배열 메서드 `indexOf()` 의 콜백함수 버전. 고차함수 find()의 리턴값이 인덱스인 버전. |
|  filter()   | 주어진 배열을 순회하면서 콜백 함수의 반환값이 true에 해당하는 요소로만 구성된 새로운 배열을 생성하여 반환. |
|  reduce()   | 콜백 함수의 실행된 반환값(initialValue)을 전달 받아 연산의 결과값이 반환.<br />첫 번째 인자(accumulator)서부터 시작해서 배열 값인 두 번째 인자(currentvalue) 을 순회하며 `accumulator+=currentvalue`을 실행. |
|   sort()    | 배열 정렬. 단, 복사본이 아닌 원 배열이 정렬됨.<br />콜백 함수를 통해 배열의 원소들을 어느 기준으로 정렬할지 지정해야함 |
|   some()    | 배열 메서드인 `include()`의 콜백 함수 버전. <br />include는 값이 있냐에 따른 bool이면, some은 함수의 로직에 따른 bool.<br />배열의 요소들을 주어진 함수(조건)을 통과하는데 한개라도 통과되면 true, 아닐때에는 false를 출력. |
|   every()   | some() 의 반대 버전. <br />배열안의 모든 요소가 주어진 함수(조건)을 모두 통과하면 true, 한 요소라도 통과하지 못하면 false를 출력. |

> **💡 forEach와 map의 차이**
>
> 두 메서드 모두 배열을 순회하는 것은 동일하지만
>
> forEach()의 경우 각 요소를 참조한 연산이 이루어지고,  
> map()의 경우엔 각 요소를 다른 값으로 맵핑한 새로운 배열이 반환되는 점에 차이가 있다.
>
> 정리하면 forEach()는 for문을 대체하여 사용하고 map()은 연산의 결과로 새로운 배열을 생성하고자 할 때 사용된다.

<br>

## 객체 리터럴

자바스크립트는 객체 기반의 프로그래밍 언어로, 원시 타입(숫자, 문자열, 불리언, undefined)을 제외한 모든 것이 객체이다.

### 객체(Object)

객체는 0개 이상의 프로퍼티(property)로 구성된 집합으로, 프로퍼티는 `key`와 `value`로 구성된다. 

프로퍼티의 값으로 함수가 올 경우를 `method`라고 한다.

```javascript
var person = {
    name: "홍길동",      		  // ← 프로퍼티
    birthday: "030219",
    pId: "1234567",    
    fullId: function() { 		// ← 메서드
        return this.birthday + this.pId;
    }
};

person.name    // 홍길동
person["name"] // 홍길동
person.fullId() // 0302191234567
person.fullId;  // function () { return this.birthday + this.pId; } 
```

> 💡 **함수와 메서드의 차이**
>
> 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 
>
> **프로퍼티 값이 함수일 경우**, 일반 함수와 구분하기 위해 메서드(method)라 부른다.  
> 객체 내부에서 객체의 프로퍼티(상태)를 참조하고 조작할 수 있는 동작을 메서드라 부른다.
>
> 즉, **메서드는 객체에 묶여 있는 함수를 의미한다.**

<br>

### 객체를 생성하는 방법

> 1\. 객체 리터럴
> 2\. 생성자
> 3\. Object.create()
> 4\. ES6에서 Class 키워드

#### 1. 객체 리터럴

리터럴은 사람이 이해할 수 있는 문자나 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.  

객체 리터럴은 중괄호`({})` 내에 0개 이상의 프로퍼티를 정의한다.  
각각의 프로퍼티는 이름과 값을 콜론(:)으로 연결하고, 쉼표(,)를 사용해 다른 프로퍼티와 구분한다.  
객체 리터럴의 중괄호는 코드 블록을 의미하는 것이 아니라 값으로 평가되기 때문에 닫는 괄호 뒤에는 세미콜론(;)을 붙인다.

```javascript
var myObj = {
    name: '카레유',
    age: 20,
    hello: function(){
        return `이름은 ${this.name}이고, 나이는 ${this.age}입니다.`;
    }
};

console.log(myObj);  // { name: '카레유', age: 20, hello: [Function: hello] }
```

> 🔍 **ES6 부터 '객체 리터럴' 방식으로 객체 생성시, 아래 기능이 추가되었다.** [[참고1]](https://curryyou.tistory.com/191)[[참고2]]()
>
> 1\. 객체 내부에서 프로퍼티의 key를 [계산식] 로 사용할 수 있다.  
> 2\. 프로퍼티/메서드 생성 시, 변수만 설정해주면 된다.(key:value 불필요)  
> 3\. 메서드 생성 시, 객체의 메서드 생성시, key값과 function 키워드를 생략할 수 있다.  
> 4\. \__proto__ 프로퍼티에 의한 상속이 가능하다.

#### 2. 생성자

- **new Object()** : new 연산자를 통해 Object객체의 생성자 함수를 호출.

   ```javascript
   var myObj = new Object();
   
   myObj.name = '카레유';
   myObj['age'] = 20;
   
   myObj.hello = function(){
       return `이름은 ${this.name}이고, 나이는 ${this.age}입니다.`;
   };
   ```

- **new 생성자()** :  Number, String, Array 등의 자바스크립트에서 제공하는 내장 객체로 생성.

   ```javascript
   var str = new String('hello');	// String객체 생성하기
   var arr = new Array([1, 2, 3]);	// Array(배열)객체 생성
   var day = new Date();			// Date 타입의 객체 생성
   ```

- **new 사용자 정의 생성자() :** 직접 생성자 함수를 만들어 객체를 생성

   ```javascript
   // 생성자 함수 만들기
   var SelfObj = function(name, age){
       this.name = name;  // this는 자신이 속한 객체를 참조하는 '자기 참조 변수'다.
       this.age = age;
       this.hello = function(){
           return `이름은 ${this.name}이고, 나이는 ${this.age}입니다.`;
       }
   }
   
   // 객체 생성하기
   var selfObj = new SelfObj('카레유', 20);
   console.log(selfObj); // SelfObj { name: '카레유', age: 20, hello: [Function] }
   ```

#### 3. Object.create()

프로토타입 상속을 통해 객체를 만드는 방식이다.

```javascript
// 부모 객체 생성
var parent = {a:10, b:20};

// 자식 객체 생성(부모의 프로퍼티를 상속 받음)
var child = Object.create(parent);
console.log(child.a);  // 10
```

\* child객체에서 parent객체의 프로퍼티인 a값을 참조할 수 있다.

#### 4. ES6에서 Class 키워드

하나의 모델이 되는 청사진(class)을 만들고, 그 청사진을 바탕으로 한 객체(instance)를 만드는 프로그래밍 패턴

ES5에서의 함수로 정의한 클래스와는 다르게, ES6의 클래스 선언의 메서드 정의는 클래스 내부에 직접 생성자를 정의할 수 있고
클래스 메소드를 생성할 때 function키워드를 사용할 필요가 없어 간결하다.

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHi() {
    console.log(`Hi ${this.name}`);
  }
}

person1 = new Person('hyun', 7); // Person {name: "hyun", age: 7}
person1.sayHi(); // Hi hyun 
```

<br>

### 전역 객체

전역 객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 `window`, Server-side(Node.js)에서는 `global` 객체를 의미한다.

전역 객체는 코드가 실행되기(런타임) 이전 단계에 자바스크립트 엔진에 의해  생성이 되며 constructor가 없기 때문에 new 연산자를 이용하여 새롭게 생성할 수 없다. 즉, 개발자가 전역 객체를 생성하는 것은 불가능하다.

전역 객체는 전역 스코프(Global Scope)를 갖게 된다. 전역 객체의 자식 객체를 사용할 때 전역 객체의 기술은 생략할 수 있다.

var키워드로 선언한 전역 변수, 글로벌 영역에 선언한 전역 함수, 표준 빌트인 객체(Object, String, Number, Function, Array...)는 모두 **전역 객체의 프로퍼티**이다.

```javascript
// var키워드로 선언한 전역 변수
var ga = 'Global variable';
console.log(ga);
console.log(window.ga);

// 글로벌 영역에 선언한 전역 함수
function foo() {
  console.log('invoked!');
}
window.foo();

// 표준 빌트인 객체 alert
alert('Hello world!');
// window.alert('Hello world!');
```

<br>

## 원시 값과 객체 비교 

자바스크립트가 제공하는 7가지 데이터 타입은 크게 **원시 타입**과 **객체 타입**으로 구분 가능하다.

1\. 원시값은 변경 불가능한 값이나 객체는 변경 가능한 값이다.  
2\. 원시 값을 변수에 할당하면 변수에는 실제 값이, 객체를 할당하면 변수에는 참조 값(메모리 주소)이 저장된다.  
3\. 원시 값은 값에 의한 전달(원본 값이 복사)이, 객체는 참조에 의한 전달(메모리 주소가 복사)이다.

> 💡 **데이터의 타입을 크게 2개로 나누는 이유**
>
> 원시 타입에 포함되는 데이터들의 크기는 고정적이고 메모리를 적게 차지하는 편인데 반해,   
> 객체 타입에 포함되는 데이터들의 크기는 유동적이기 때문에 언제든지 메모리를 많이 차지할 가능성이 있기 때문이다.

### Pass-by-value(값에 의한 전달)

**원시 타입**은 값(value)으로 전달된다. 즉, 값이 복사되어 전달된다. 이를 **pass-by-value(값에 의한 전달)**라 한다.

원시 타입은 값이 한번 정해지면 변경할 수 없다.(immutable) 또한 이들 값은 런타임(변수 할당 시점)에 메모리의 **스택 영역**(Stack Segment)에 고정된 메모리 영역을 점유하고 저장된다.

```javascript
// Pass-by-value
var a = 1;
var b = a;

console.log(a, b);    // 1  1
console.log(a === b); // true

a = 10;
console.log(a, b);    // 1  10
console.log(a === b); // false
```

### Pass-by-reference(참조에 의한 전달)

**참조 타입**은 참조(Reference) 방식으로 전달된다. 즉, 결코 복사되지 않는다. 이를 **pass-by-reference(참조에 의한 전달)**라 한다.  

원시 타입은 값이 한번 정해지면 변경할 수 없지만, 객체는 프로퍼티를 변경, 추가, 삭제가 가능하므로 변경 가능(mutable)하다.  
따라서 객체 타입은 동적으로 변화할 수 있으므로 어느 정도의 메모리 공간을 확보해야 하는지 예측할 수 없기 때문에 런타임에 메모리 공간을 확보하고 메모리의 **힙 영역**(Heap Segment)에 저장된다. 

```javascript
// Pass-by-reference
var foo = {
  val: 10
}

var bar = foo;
console.log(foo.val, bar.val); // 10 10
console.log(foo === bar);      // true

bar.val = 20;
console.log(foo.val, bar.val); // 20 20
console.log(foo === bar);      // true
```

<br>

---

**참고**

\- 배열

[자바스크립트 배열은 배열이 아니다](https://poiemaweb.com/js-array-is-not-arrray)

[[JS] 📚 자바스크립트 Array 메서드 💯 총정리](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-Array-%EB%A9%94%EC%86%8C%EB%93%9C-%E2%9C%8F%EF%B8%8F-%EC%A0%95%EB%A6%AC#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_array_%EB%A9%94%EC%86%8C%EB%93%9C)

[📚 JavaScript 배열 고차 함수 총정리](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EB%B0%B0%EC%97%B4-%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98-%EC%B4%9D%EC%A0%95%EB%A6%AC-%F0%9F%92%AF-mapfilterfindreducesortsomeevery#.every)

\- 객체 리터럴

[[Javascript] 객체 리터럴(object literal)](https://velog.io/@nxnaxx/Javascript-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4)

[[JS] 자바스크립트 객체 생성, 접근 방법](https://curryyou.tistory.com/189)

[JavaScript : 객체 ( Object ) 추가 정리 + ES6 클래스](https://velog.io/@duboo/JavaScript-%EA%B0%9D%EC%B2%B4-Object-%EC%B6%94%EA%B0%80-%EC%A0%95%EB%A6%AC-ES6-%ED%81%B4%EB%9E%98%EC%8A%A4)

\- 원시 값과 객체 비교 

[[모던 자바스크립트 스터디] 원시 값과 객체 비교](https://ffoorreeuunn.tistory.com/493)

[[모던자바스크립트 Deep Dive] 5.10 Obejct 객체](https://poiemaweb.com/js-object#4-pass-by-reference)
