# 데이터 타입

자바스크립트(ES6)는 7개의 데이터 타입을 제공한다. 7개의 데이터 타입은 원시 타입(primitive type)과 객체 타입(object/reference type)으로 분류할 수 있다.

| 구분      | 데이터 타입         | 설명                                                |
| --------- | ------------------- | --------------------------------------------------- |
| 원시 타입 | 숫자(number)타입    | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
| 원시 타입 | 문자열(string)타입  | 문자열                                              |
| 원시 타입 | 불리언(boolean)타입 | 논리적 참(true)과 거짓(false)                       |
| 원시 타입 | undefined타입       | var 키워드로 선언된 변수에 암묵적으로 할당되는 값   |
| 원시 타입 | null 타입           | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값   |
| 원시 타입 | 심벌(symbol) 타입   | ES6에서 추가된 7번째 타입                           |
| 원시 타입 | BigInt 타입         | 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형  |
| 객체 타입 |                     | 객체, 함수, 배열 등                                 |



### undefined 타입

`undefined` 타입의 값은`undefined` 가 유일하다.

`var` 키워드로 선언한 변수는 암묵적으로 `undefined`로 초기화된다. 다시 말해, 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태(대부분 비어 있지 않고 쓰레기 값(garbage value)이 들어있다)로 내버려두지 않고 자바스크립트 엔진이 `undefined`로 초기화한다. 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 `undefined`가 반환된다.

이처럼 `undefined`는 개발자가 의도적으로 할당하기 위한 값이 아닌 js 엔진이 변수를 초기화할 때 사용하는 값이다. 변수를 참조했을 때 `undefined` 가 반환된다면 초기화 되지 않은 변수라는 것을 간파할 수 있다.

`undefined`를 개발자가 의도적으로 변수에 할당한다면 `undefined`의 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장하지 않는다.

변수에 값이 없다는 것을 명시하고 싶을 때는 null을 할당한다.

### 심벌 타입

심벌(symbol)은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌은 Symbol 함수를 호출해 생성한다. 이때 생성된 심벌값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.

```javascript
// 위, 아래, 왼쪽, 오른쪽을 나타내는 상수를 정의한다.
// 중복될 가능성이 없는 심벌 값으로 상수 값을 생성한다.
const Direction = {
  UP: Symbol("up"),
  DOWN: Symbol("down"),
  LEFT: Symbol("left"),
  RIGHT: Symbol("right"),
};

const myDirection = Direction.UP;

if (myDirection === Direction.UP) {
  console.log("You are going UP.");
}
```



### 데이터 타입의 필요성

1. 데이터 타입에 의한 메모리 공간의 확보와 참조

   - 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 즉, 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.

     > **데이터 타입에 따라 확보되는 메모리 공간의 크기**
     > ECMAScript 사양은 문자열과 숫자 타입 외의 데이터 타입의 크기를 명시적으로 규정하고 있지는 않다. 따라서 문자열과 숫자 타입을 제외하고 데이터 타입에 따라 확보되는 메모리 공간의 크기는 자바스크립트 엔진 제조사의 구현에 따라 다를 수 있다. 단, ECMAScript 사양에 숫자 타입은 배정밀도 64비트 부동소수점 형식을 사용한다고 명시되어 있고, 배정밀도 64비트 부동소수점 형식은 8바이트로 숫자를 표현하므로 이 책에서는 숫자 값의 크기를 8바이트로 설명한다.

   - 값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(바이트 수)를 알아야 한다.

     > **심벌 테이블**
     >
     > 컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.

2. 데이터 타입에 의한 값의 해석
   - 메모리에서 읽어 들인 2진수를 어떻게 해석할까
   - 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만 문자열로 해석하면 'A'이다.



### 정적 타이핑

C나 자바 같은 정적 타입(static/strong type)언어는 변수를 선언할 때 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언(explicit type declaration)이라 한다. 다음은 C에서 정수 타입의 변수를 선언하는 예다.

```c
// c 변수에는 1바이트 정수 타입의 값(-128 ~ 127)만을 할당할 수 있다.
char c;

// num 변수에는 4바이트 정수 타입의 값(-2,124,483,648 ~ 2,124,483,647)만을 할당할 수 있다.
int num;
```

정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다. 정적 타입 언어는 컴파일 시점에 타입 체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행한다. 만약 타입 체크를 통과하지 못했다면 에러를 발생시키고 프로그램의 실행 자체를 막는다. 이를 통해 타입의 일관성을 강제함으로써 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다. 

대표적인 정적타입 언어로는 C, C++, Java, Kotlin, Go, Haskell, Rust, Scala 등이 있다.



### 동적 타이핑

자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다. 다만 var, let, const 키워드를 사용해 변수를 선언할 뿐이다. 자바스크립트의 변수는 정적 타입 언어와 같이 미리 선언한 데이터 타입의 값만 할당할 수 있는 것이 아니다. 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다.

```javascript
var foo;
console.log(typeof foo); // undefined

foo = 3;
console.log(typeof foo); // number

foo = null;
console.log(typeof foo); // object

foo = Symbol(); // 심벌
console.log(typeof foo); // symbol

foo = {}; // 객체
console.log(typeof foo); // object

foo = []; // 배열
console.log(typeof foo); // object

foo = function () {}; // 함수
console.log(typeof foo); // function
```

자바스크립트의 변수에는 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있으므로 정적 타입 언어에서 말하는 데이터 타입과 개념이 다르다. 정적 타입 언어는 변수 선언 시점에 변수의 타입이 결정되고 변수의 타입을 변경할 수 없다. 자바스크립트에서는 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 변수의 타입을 언제든지 자유롭게 변경 가능하다.

다시 말해, **자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론 type inference)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.** 이러한 특징을 **동적 타이핑(dynamic typing)**이라 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 **동적 타입(dynamic/weak type)**언어라 한다. 

대표적인 동적 타입 언어로는 JavaScript, Python, PHP, Ruby, Lisp, Perl 등이 있다.

변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다. 따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는 것이 더 적절하다. 변수는 값에 묶여 있는 값에 대한 별명이기 때문이다.



# 타입 변환과 단축 평가

자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환(explicit coercion)** 또는 **타입 캐스팅(type casting)**이라 한다.

개발자의 의와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 **암묵적 타입 변환(implicit coercion)**또는 **타입 강제 변환(type coercion)**이라 한다.

```javascript
var x = 10;

// 숫자를 문자열로 타입 캐스팅한다.
var str = x.toString();
console.log(typeof str, str); // string 10

// x 변수의 값이 변경된 것은 아니다.
console.log(typeof x, x); // number 10
```

명시적 타입 변환이나 암묵적 타입 변환이 기존 원시 값(위 예제의 경우 x 변수의 값)을 직접 변경하는 것은 아니다. 원시 값은 변경 불가능한 값(immutable value)이므로 변경할 수 없다. 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다.

암묵적 타입 변환은 기존 변수 값을 재할당하여 변경하는 것이 아니다. 자바스크립트 엔진은 표현식을 에러 없이 평가하기 위해 피연산자 값을 암묵적 타입 변환해 새로운 타입의 값을 만들어 단 한 번 사용하고 버린다.

명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다.

따라서 자신이 작성한 코드에서 암묵적 타입 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지, 그리고 타입 변환된 값으로 표현식이 어떻게 평가될 것인지 예측 가능해야한다. 

### 암묵적 타입 변환

자바스크립트 엔진이 표현식을 평가할 때 개발자의 의도와는 상관없이 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환(암묵적 타입 변환)하는 것. 

암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다. 

1. **문자열 타입으로 변환**

   ```javascript
   1 + '2' // -> "12"
   ```

   위 예제의 + 연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.

2. **숫자 타입으로 변환**

   ```js
   1 - '1' // -> 0
   1 * '10' // -> 10
   1 / 'one' // -> NaN
   ```

   위 예제의 연산자는 모두 산술 연산자다. 산술 연산자의 역할은 숫자 값을 만드는 것이다. 자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN 이 된다.

   빈 문자열(`''`), 빈 배열(`[]`), `null`, `false` 는 0으로, `true`는 1로 변환된다. 객체와 빈 배열이 아닌 배열, `undefined`는 변환되지 않아 `NaN`이 된다는 것에 주의하자.

3. **불리언 타입으로 변환**

   ```js
   if ('') console.log(x);
   ```

   `if`문이나 `for` 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참/거짓으로 평가되어야 하는 표현식이다. 자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.

   이때 **자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분**한다. 즉, 제어문의 조건식과 같은 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 `true`로, Falsy 값은 `false`로 암묵적 타입 변환된다.

   ```js
   // false로 평가되는 Falsy 값
   false
   undefined
   null
   0, -0
   NaN
   ''(빈 문자열)
   ```

   Falsy 값 외의 모든 값은 모두 `true`로 평가되는 Truthy 값이다.

### 명시적 타입 변환

개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다. 표준 빌트인 생성자 함수(`String, Number, Boolean`)를 `new` 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 그리고 앞에서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다.

> **표준 빌트인 생성자 함수와 빌트인 메서드**
>
> 표준 빌트인 생성자 함수와 표준 빌트인 메서드는 자바스크립트에서 기본 제공하는 함수다. 표준 빌트인 생성자 함수는 객체를 생성하기 위한 함수이며 new 연산자와 함께 호출한다. 표준 빌트인 메서드는 자바스크립트에서 기본 제공하는 빌트인 객체의 메서드다. 

1. **문자열 타입으로 변환**

   1. `String` 생성자 함수를 `new` 연산자 없이 호출하는 방법
   2. `Object.prototype.toString` 메서드를 사용하는 방법
   3. 문자열 연결 연산자를 이용하는 방법

   ```js
   String(1); // -> "1"
   (1).toString(); // -> "1"
   1 + ''; // -> "1"
   ```

2. **숫자 타입으로 변환**

   1. `Number` 생성자 함수를 `new` 연산자 없이 호출하는 방법
   2. `parseInt, parseFloat` 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능)
   3. \+ 단항 산술 연산자를 이용하는 방법
   4. \* 산술 연산자를 이용하는 방법

   ```js
   Number('0'); // -> 0
   parseInt('0'); // -> 0
   +'0'; // -> 0
   '0' * 1; // -> 0
   ```

3. **불리언 타입으로 변환**

   1. `Boolean` 생성자 함수를 `new` 연산자 없이 호출하는 방법
   2. ! 부정 논리 연산자를 두 번 사용하는 방법

   ```js
   Boolean('x'); // -> true
   !!'x'; // -> true
   ```



### 단축 평가

단축 평가(short-circuit evaluation)는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다. 

```js
'Cat' && 'Dog' // -> "Dog"
'Cat' || 'Dog' // -> "Cat"
```

논리곱(&&) 연산자는 논리 연산의 결과를 결정하는 두 번째 피연산자, 즉 문자열 'Dog'를 그대로 반환한다.

논리합(||) 연산자는 논리 연산의 결과를 결정하는 첫 번째 피연산자, 즉 문자열 'Cat'을 그대로 반환한다.

이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환하는 것을 단축 평가라고 한다.

| 단축 평가 표현식  | 평가 결과 |
| :---------------- | --------- |
| true              | true      |
| false             | anythin   |
| true && anything  | anything  |
| false && anything | false     |




# Reference

자바스크립트 DeepDive