# 에러

> 자바스크립트에서 에러 처리를 구현하는 방법은 크게 2가지이다.
>
> - 예외적인 상황 발생시 반환하는 값(null 또는 -1)
>   ⇒ if문, 단축 평가, 옵셔널 체이닝 연산자를 통해 확인해서 처리
> - 에러 처리 코드를 미리 등록해두고 에러가 발생하면 에러 처리 코드로 점프
>   ⇒ try...catch...finally문 이용
>
> 일반적으로 두 번째 방법을 에러 처리라고 부른다.



### JS 에러 구문의 종류

| **종류**    | **설명**                                                     |
| ----------- | ------------------------------------------------------------ |
| **try**     | 코드 블록에서 오류를 테스트할 수 있는 구문                   |
| **catch**   | 오류를 처리할 수 있는 구문                                   |
| **throw**   | 사용자 지정 오류를 만들 수 있는 구문                         |
| **finally** | 결과와 관계없이 try 및 catch 후에 코드를 실행할 수 있는 구문 |



### Error 객체

#### Error 생성자 함수

Error 생성자 함수는 에러 객체를 생성한다.
Error 생성자 함수에는 에러를 상세히 설명하는 에러 메세지를 인수로 전달할 수 있다.

```jsx
const error = new Error('invalid');
```

Error 생성자 함수가 생성한 에러 객체는 message 프로퍼티와 stack 프로퍼티를 갖는다.

- message 프로퍼티 : Error 생성자 함수에서 인수로 전달한 에러 메세지
- stack 프로퍼티 : 에러를 발생시킨 콜스택의 호출 정보를 나타내는 문자열

#### Error 생성자 함수 종류

| 생성자 함수    | 인스턴스                                                     |
| -------------- | ------------------------------------------------------------ |
| Error          | 일반적 에러 객체                                             |
| SyntaxError    | 자바스크립트 문법에 맞지 않는 문을 해석할 때 발생하는 에러 객체 |
| ReferenceError | 참조할 수 없는 식별자를 참조했을 때 발생하는 에러 객체       |
| TypeError      | 피연산자 또는 인수의 데이터 타입이 유효하지 않을 때 발생하는 에러 객체 |
| RangeError     | 숫자값의 허용 범위를 벗어낫을 때 발생하는 에러 객체          |
| URIError       | encodeURI 또는 decodeURI 함수에 부적절한 인수를 전달했을 때 발생하는 에러 객체 |
| EvalError      | eval 함수에서 발생하는 에러 객체                             |



### 기본 에러 처리

예외 처리를 하는 기본 구문은 다음과 같다. 

`try{}` 구문 안에는 예외가 발생할 수 있는 코드를 작성하고, `try()` 구문은 예외가 발생하는지를 체크한다.

```js
try{
    // 예외를 발생시킬 수 있는 코드
}
```

이 구문에서 예외가 발생했을 때 할 수 있는 처리는 없다. 예외의 발생여부만 체크한다.

에러가 발생했을 때 처리하는 코드는 `catch(Error){}` 구문으로 작성한다. `catch(){}` 구문은 단독으로는 사용할 수 없고, 반드시 `try{}` 구문과 함께 사용해야 한다. 

에러가 발생하면 에러메시지를 표시하고 코드 실행이 종료되는 것이 아니라 코드 실행이 `catch(){}` 구문으로 넘어오고 코드가 실행된다.

이때 `catch(){}` 구문은 인자(Parameter)로 Error(Error) 객체를 함께 넘긴다. 에러 객체에는 에러가 발생한 이유를 알려주는 여러가지 정보가 들어있다.

```js
try{
    // 예외를 발생시킬 수 있는 코드
} catch(err){ // 인자로 에러(Error) 객체가 넘어옴
    // 에러가 발생하면 실행되는 코드
}
```



### 임의로 에러 발생 시키기

>  실제로 에러가 발생하지 않아도 임의로 에러를 발생시킬 수 있다.
>
> 예를 들어 조건에 맞지 않는 값이 들어왔을 경우 에러를 발생시키고 에러 핸들링 처리를 하도록 해서 이후 발생할 에러를 미리 막을 수 있다. 
>
> 적절하게 에러를 발생시키고 에러 처리를 하는 것은 표준적인 자바스크립트 코딩 방법이며, 간결하고 유지보수가 쉬운, 그리고 코드가 더 안정적으로 실행되도록 하는 권장 코딩 방법이다.

에러를 발생시키는 구문은 `throw`이다.

간단하게 다음과 같이 작성하면 에러가 발생한다. 물론 에러 핸들링 처리를 하지 않으면 `throw`에러를 발생시킨 지점에서 코드 실행은 멈춘다.

```js
throw "에러 발생!";
```

콘솔에는 다음과 같이 에러가 표시된다.

![throwError](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNoMpF%2Fbtrgu1QsOYf%2FjakshicN9bJiTGFlx87OY0%2Fimg.jpg)

기본 에러 발생 외에 여러가지 에러 객체를 이용해 다양한 에러를 발생시킬 수 있다.

```js
throw "에러발생";
throw Error("에러발생");
throw new ReferenceError("참조 에러발생");
UserException("사용자 정의 에러 발생");
```



### finally로 무조건 실행되는 코드 추가하기

finally 구문 또한 catch 구문처럼 try 구문에 종속된 구문이다. 단독으로는 사용할 수 없다.

try 구문의 실행 코드 영역과 catch 구문의 실행 코드 영역이 어느 쪽이 실행돼도, 마지막에는 무조건 실행돼야 하는 코드를 finally 구문에 추가할 수 있다.

예를 들어 파일에서 내용을 읽은 후 파일을 닫는 처리를 하거나 비정상 값에 대해 에러 처리를 한 후 값을 강제로 기본 값으로 보정하는 처리를 finally 구문으로 할 수 있다.

```js
try{
    // 실행 코드
}finally{
    // 항상 실행
}
// or
try{
    // 실행 코드
}catch(err){
    // 에러 처리
}finally{
    // 항상 실행
}
```







# 모듈

프로그래밍에서 '모듈(module)'이란 프로그램을 구성하는 구성요소의 일부이다.

개발하는 애플리케이션의 크기가 커지면 확장성과 유지보수 측면에서 파일을 여러 개로 분리하는 시점이 온다. 이때 분리된 파일 각각을 '모듈' 이라고 부르고, 보통 클래스 하나 혹은 특정한 목적을 가진 복수의 함수로 구성된 라이브러리 하나로 구성된다.

이렇게 파일을 모듈화 하여 관리하면 다음과 같은 장점이 있다.

1. 프로그램의 효율적인 관리 및 성능 향상
2. 전체적인 소프트웨어 이해의 용이성 증대 및 복잡성 감소
3. 소프트웨어 디버깅, 테스트, 통합, 수정 시 용이성 제공
4. 기능의 분리가 가능하고 인터페이스가 단순
5. 오류의 파급효과를 최소화
6. 모듈의 재사용 가능으로 개발과 유지보수가 용이



### ✅ 자바스크립트의 모듈

> 초기 스크립트는 크기도 작고 기능도 단순해 자바스크립트는 긴 세월 동안 모듈 관련 표준 문법 없이 성장이 가능했다.
>
> 하지만 스크립트의 크기가 점차 커지고 기능도 복잡해지자 자바스크립트 커뮤니티는 특별한 라이브러리를 만들어 필요한 모듈을 언제든지 불러올 수 잇게 해준다거나 코드를 모듈 단위로 구성해주는 방법을 만드는 등 다양한 시도를 하게 된다.
>
> - AMD : 가장 오래된 모듈 시스템 중 하나로 require.js 라는 라이브러리를 통해 처음 개발되었다.
> - CommonJS : Node.js 서버를 위해 만들어진 모듈 시스템
> - UMD : AMD 와 CommonJS와 같은 다양한 모듈 시스템을 함께 사용하기 위해 등장했다.
>
> 모듈 시스템은 2015년 표준으로 등재되었다. 이 이후 관련 문법은 진화를 거듭해 이제는 대부분의 주요 브라우저와 Node.js가 모듈 시스템을 지원하고 있다.



자바스크립트에서 모듈은 특수한 지시자 `export`와 `import`를 통해 불러온다.

- `export`를 변수나 함수 앞에 붙이면 외부 모듈에서 해당 변수나 함수에 접근할 수 있다.

```js
// file1.js

export function sayHi(user) {
    alert(`Hello, ${user}!`);
}
```

- `import` 를 사용하면 외부 모듈의 기능을 가져올 수 있다.

```js
// main.js

import { sayHi } from './file1.js';

alert(sayHi); // 함수
sayHi('John'); // Hello, John!
```

- 브라우저에서 `import` / `export` 를 사용하려면 `<script type = "module">` 같은 속성이 필요하다.



### 모듈의 핵심 기능

1. '**엄격 모드(Strict mode)**'로 실행된다.

   => 선언되지 않은 변수에 값을 할당하는 등의 코드는 에러를 발생시킨다.

2. 모듈 레벨 스코프

   => 모듈을 **자신만의 스코프**가 있다. 따라서 모듈 내부에 정의한 변수나 함수는 다른 스크립트에서 접근할 수 없다.

   (여기서 모듈은 파일 하나이고, 스크립트 하나는 모듈 하나이다. 즉, 다른 스크립트에서 `import`를 하지 않고 외부 스크립트(모듈)를 사용할 수 없다는 소리)

3. **단 한 번만 평가**된다.

   : 동일한 모듈이 여러 곳에서 사용되더라도 모듈은 최초 호출 시 단 한 번만 실행된다. 실행 후 결과는 이 모듈을 가져가려는 모든 모듈에 내보내진다.

   (따라서 `import`로 모듈을 가져온 스크립트 A.js 에서 모듈 호출 후 해당 모듈의 변수를 변경하면 그 모듈을 사용하는 스크립트 B.js에서도 변경된 값이 적용된다.)

4. `import.meta`

   : import.meta 객체는 현재 모듈에 대한 정보를 제공해준다. (ex) 스크립트 url 정보 등)

5. `'this'`는 `undefined`

   : 일반 스크립트의 this는 전역 객체인 것과 달리 **모듈 최상위 레벨의 this는 undefined**이다.

6. 실제 애플리케이션을 출시할 때는 성능 개선 등의 이점 때문에 **웹팩**과 같은 번들러를 사용해 모듈을 한 데 묶어(번들링) 프로덕션 서버에 올리는 방식을 사용한다.



## Reference

[[JavaScript] 모듈이란?](https://velog.io/@syoung125/%EA%B0%9C%EB%85%90%EA%B3%B5%EB%B6%80-1.-Javascript)

[자바스크립트 에러 처리(Error Handling) 총정리](https://blogpack.tistory.com/1070)

[Javascript 에러처리](https://velog.io/@dev-redo/Javascript-%EC%97%90%EB%9F%AC%EC%B2%98%EB%A6%AC)

[[JS강좌] 27강 자바스크립트 에러(Error) - 오쌤의 니가스터디](https://ossam5.tistory.com/241)