# Suspense

Suspense는 React에서 비동기 작업을 관리하기 위한 기능이다. Suspense는 컴포넌트 일부 데이터를 기다리고 있음을 나타낼 수 있다.

예를 들어, 리액트는 다음과 같이 `<UserList/>` 컴포넌트가 포함된 JSX 코드를 렌더링 할 때, `<UserList/>` 함수를 바로 호출한다.

```react
<UserList />
```

하지만 컴포넌트를 아래와 같이 Suspense로 감싸주면 컴포넌트의 렌더링을 특정 작업 이후로 미루고, 그 작업이 끝날 때 까지는 `fallback` 속성으로 넘긴 컴포넌트를 대신 보여줄 수 있다.

```react
<Suspense fallback={<Spinner />}>
  <UserList />
</Suspense>
```

물론 컴포넌트가 렌더링 되기 전에 구체적으로 어떤 작업이 일어나야 하는지는 `<UserList/>` 함수 안에 명시되어 있는 것이다.



### 🔍 Suspense 사용 전

Suspense 사용 전 리액트에서 비동기 데이터를 읽어와야 하는 컴포넌트는 어떻게 작성했을까?

아마도 클래스 기반 컴포넌트를 사용할 때는 생명주기 함수는 `componentDidMount()`를 구현하고, 함수형 컴포넌트를 사용할 때는 `useEffect()` 훅 함수를 호출했을 것이다. 이러한 방법은 다음과 같은 문제가 발생한다.

1. waterfall 현상 발생

   최종 사용자 경험 측면에서 UI가 마치 폭포처럼 순차적으로 나타나는 현상이 발생할 수 있다.

   특히 한 페이지 상의 여러 컴포넌트에서 동시에 비동기 데이터를 읽어오는 경우 자주 발생하는 문제로, 상위 컴포넌트의 데이터 로딩이 끝나야지만 하위 컴포넌트의 데이터 로딩이 시작될 수 있기에 주로 발생한다.

2. 경쟁 상태 취약

   초기 랜더링 후에 데이터 로딩 후 다시 렌더링을 수행하는 방법은 경쟁 상태(race conditions)에 취약하다. 비동기 통신은 반드시 요청한 순서대로 데이터가 응답된다는 보장이 없기 때문에 의도치 않게 싱크가 맞지 않는 데이터를 제공할 수도 있다.

3. 명령형 코드

   `if`조건문을 사용하여 어떤 컴포넌트를 보여줄 지 제어하는 것은 명령형(imperative) 코드에 가깝기 때문에 선언적(declarative) 코드를 지향하는 React의 기본 방향성과 맞지 않게 느껴진다.

   또한 기본적으로 데이터 로딩과 UI 렌더링이라는 두 가지 전혀 다른 목표가 하나의 컴포넌트 안에 커플링(coupling)되어 코드가 읽기 어려워 지고 테스트를 작성하기도 힘들어진다.



### 💡 Suspense 사용 후

Suspense를 사용한다면,

1. 비동기적인 코드를 동기적인 방식(async await과 유사) 으로 작성할 수 있다. 리액트는 이를 위해 마이크로 태스크를 이용한다.
2. 중첩된 여러 개의 컴포넌트 중 특정 컴포넌트에 대한 로딩 상태 관리에 대해 걱정하지 않고 쉽게 코드를 작성할 수 있게 된다.
3. 중첩된 여러 개의 컴포넌트에서 데이터 표시의 순서에 상관없이 병렬적으로 데이터를 페칭할 수 있다.

#### 📌 Usages

- 컨텐츠가 로딩 중일 때 fallback을 보여주기

  ```react
  <Suspense fallback={<Loading />}>
    <Albums />
  </Suspense>
  ```

  가장 대표적인 예시이다. `<Albums />`가 컴포넌트 내부에서 비동기적으로 데이터를 가져오고 있을 때, 이를 가장 가까운 Suspense 바운더리에서 캐치한 후 로딩 컴포넌트를 보여줄 수 있다.

  이때 주의할 점은, `Suspense`의 `children`은 **suspense-enabled data**여야 한다는 점이다. children 컴포넌트가 `useEffect`를 사용하거나 이벤트 핸들러를 통해 데이터를 가져온다면 Suspense는 이를 감지하지 못한다.

1. 여러 개의 컨텐츠를 동시에 보여주고 싶을 때

   ```react
   <Suspense fallback={<Loading />}>
     <Biography />
     <Panel>
       <Albums />
     </Panel>
   </Suspense>
   ```

   Suspense 안에 있는 모든 트리는 단일 단위로 취급된다. `Biography`, `Albums` 컴포넌트의 데이터 fetching이 마무리되어야 해당 컨텐츠가 보이게 된다.

2. 각 컨텐츠의 타이밍이 다를 때

   ```react
   <Suspense fallback={<BigSpinner />}>
     <Biography />
     <Suspense fallback={<AlbumsGlimmer />}>
       <Panel>
         <Albums />
       </Panel>
     </Suspense>
   </Suspense>
   ```

   Suspense 컴포넌트는 겹쳐서 사용할 수 있다. 위 컴포넌트에서 `Biography` 컴포넌트는 `Albums` 컴포넌트를 기다리지 않아도 된다.

   컴포넌트 단위로 로딩 UI를 적용할 수 있다는 것이 큰 장점이고, 디자이너의 요구 사항에 맞춰 전체 페이지를 한 번에 보여줄지, 아니면 특정 컨테이너 단위로 보여줄지 결정하면 된다.

3. fetch 한 컨텐츠가 로딩 중일 때, stale한 컨텐츠를 보여주고 싶을 때

   ```react
   <Suspense fallback={<h2>Loading...</h2>}>
     <SearchResults query={query} />
   </Suspense>
   ```

   검색 관련 UI를 구현할 때 유용할 것 같은 케이스이다. `SearchResults`가 데이터를 가져오는 동안, 로딩 중임을 보여준다.

   만약 이전 결과값을 그대로 유지하고 싶다면, `useDeferredValue`를 사용한다.

   ```react
   const deferredQuery = useDeferredValue(query);
   ...
   <Suspense fallback={<h2>Loading...</h2>}>
     <SearchResults query={deferredQuery} />
   </Suspense>
   ```



# Lazy Loading

레이지 로딩이란 **중요도가 떨어지거나 당장 화면에 보이지 않는 요소들의 로딩을 우선적으로 시행하지 않으면서 웹 페이지 로딩 퍼포먼스를 최적화하는 기술**을 의미한다.
레이지 로딩은 **최초 페이지 로딩 시간을 개선**하고 당장 화면에 표시되지 않는 이미지, 영상 등의 리소스를 나중에 로딩하면서 **최초 데이터 전달 양을 감소**시키는 것이다.

기존에 웹 페이지를 로딩할 때는 모든 리소스들을 한 번에 받았다. 이런 방식은 최초 로딩 시간을 늘리게 된다. 이러한 문제를 해결하기 위해 레이지 로딩을 사용한다. 
레이지 로딩을 적용하면, 화면에 당장 보여지지 않거나 아직 유저의 인터렉션이 일어나지 않은 특정 리소스들의 로딩을 딜레이 시킬 수 있다. 이러한 방식을 적용하면, 당장 필요한 컨텐츠들이 먼저 로딩되고, 다른 리소스들은 필요해질 때 로딩되기 때문에 웹 페이지의 퍼포먼스를 눈에 띄게 개선할 수 있다.



# 코어 웹 바이탈(Core Web Vitals)

코어 웹 바이탈은 웹 사이트가 검색 엔진 결과에 표시되는 위치에 영향을 미치는 세 가지 웹 성능 측정값이다.

1. 페이지 로딩 성능
2. 상호작용의 용이성
3. 사용자 관점에서 본 페이지의 시각적 안정성

사이트의 전반적인 로딩 속도, 상호작용, 웹페이지의 시각적 안정성, 보안 문제 등 여러 요소를 포함하고 있다. 구글에서는 웹 사이트에 방문하는 유저들의 경험을 좌우하는 여러 요소들 중 가장 기본이자 핵심 지표로 보기 때문에 '코어(Core)'라는 단어를 붙여 부른다.

다시 말해, 코어 웹 바이탈은 **웹 페이지의 유저들의 사용 경험을 측정하는 구글의 표준화된 측정 항목 집합**이다.

### 📌 LCP(Largest Contentful Paint, 최대 콘텐츠 렌더링 시간)

![LCP](https://web.dev/static/articles/vitals/image/largest-contentful-paint-ea2e6ec5569b6.svg?hl=ko)

LCP는 웹 페이지의 로딩 속도에 대한 지표로 콘텐츠 렌더링 시간을 의미한다. 웹 페이지가 완전히 로드되는 데 걸리는 시간을 측정하는 것이 아니라, **가장 중요한 부분이 로드되는 시점에만 집중**한다. 즉, 뷰포트내에서 가장 큰 페이지 요소(큰 텍스트 블록, 이미지 또는 비디오)를 표시하는 데 걸리는 사간을 측정한다.

- **좋음** – 가장 큰 콘텐츠 요소가 **2.5초 이내에** 렌더링
- **개선 필요** – 가장 큰 콘텐츠 요소는 **4초 이내에 렌더링되지만 2.5초보다 오래 걸림
- **나쁨** – 가장 큰 콘텐츠 요소를 렌더링하는 데 **4초 이상** 걸림

##### LCP 최적화

1. 리소스 로드 지연 제거
   1. 리소스 탐색 시 최적화
   2. 리소스에 부여되는 우선순위 최적화
2. 요소 렌더링 지연 제거
   1. 렌더링 차단 스타이 시트를 줄이거나 인라인 처리
   2. 렌더링 차단 자바스크립트 연기 또는 인라인 처리
   3. 서버 측 렌더링 사용
   4. 장기 작업 분할
3. 리소스 로드 시간 단축
   1. 리소스가 이동하는 거리 감소
   2. 네트워크 대역폭 경합 줄이기
   3. 네트워크 시간 없애기

### 📌 FID (First Input Delay, 최초 입력 반응 시간)

![FID](https://web.dev/static/articles/vitals/image/first-input-delay-thresho-4329fd6d1129a.svg?hl=ko)

**FID**는 사이트의 상호작용성과 반응성에 대한 사용자의 첫인상을 결정한다고 볼 수 있다. 왜냐하면 FID는 **사용자가 웹페이지와 상호작용을 시도하는 첫 번째 순간부터 웹페이지가 응답하는 시간을 측정하기 때문.** 

즉, 브라우저에서 다음 액션이 발생되는 시간까지의 길이를 측정한 지표이며, 밀리세컨드(ms)로 측정한다.

이 때, FID가 중요하게 여기는 요소는 요청받은 액션을 처리하는데 걸리는 시간이 아닌, 입력 지연을 시키는 시간입니다.

- **양호** – 페이지가 **100ms 미만인** 경우 페이지의 FID 점수가 매우 높다 .
- **개선 필요** – 페이지 점수가 **100ms를 초과하고 300ms 미만인** 경우 FID 점수를 개선해야 한다.
- **나쁨** – FID 점수가 **300ms보다 길면** 성능이 좋지 않은 것으로 간주된다.



### 📌 CLS(Cumulative Layout shift, 레이아웃 변경 누적 최적화)

![CLS](https://web.dev/static/articles/vitals/image/cumulative-layout-shift-t-5d49b9b883de4.svg?hl=ko)

**CLS는** 페이지가 로드될 때 페이지가 얼마나 안정적인지 측정하고 ‘시각적 안정성’을 이루고자 한다. CLS는 **모바일 중심의** 지표다. 데스크톱 웹사이트에서는 화면 크기 문제가 대부분 존재하지 않기 때문이다.

CLS는 특히 페이지 요소가 화면에서 얼마나 자주 이동하는지 측정한다. 이로 인해 사용자가 작은 모바일 화면의 콘텐츠와 상호작용 하기가 더 어려워진다. 화면 요소가 이동하는 일반적인 원인으로는 사용자가 이미 페이지 콘텐츠와 상호작용하고 탐색하기 시작한 후에 렌더링되는 광고, 이미지 및 기타 레이아웃 요소가 있다.

- **좋음** – 페이지의 CLS 점수가 **0.1 미만** 이면 좋음
- **개선 필요** – 페이지의 CLS 점수가 **0.25 미만, 0.1 이상인** 경우 개선이 필요
- **나쁨** – 페이지의 CLS 점수가 **0.25 이상으로 낮으면** 많은 작업이 필요

##### CLS 개선 방법

1. 이미지, 영상 요소에 비율 명시
   1. 이미지와 비디오 요소에 width, height 값 적기
   2. 반응형 유튜브(영상)의 경우 padding 56.25% 활용
2. 동적 추가되는 컨텐츠의 경우
   1. 스켈레톤 UI 제공
   2. 기존 콘텐츠 상단 제공은 지야ㅕㅇ
3. 애니메이션의 경우
   1. transform 사용
4. 웹 폰트의 경우
   1. 웹 폰트 최적화
   2. 비슷한 포트 사용하기





## Reference

- [React Suspense 소개 (feat. React v18)](https://www.daleseo.com/react-suspense/)
- [React Suspense 란 무엇일까?](https://byseop.com/post/@b6b6d8b1-e3ed-4b5c-84ee-43defc1875b3)
- [Medium, React Suspense란?](https://syjn99.medium.com/react-suspense%EB%9E%80-557a7d3ecd45)
- [Tistory, 레이지로딩(lazy loading)이란?](https://seo-tory.tistory.com/84)
- [tbwakorea, 코어 웹 바이탈 (Core Web Vitals)이란?](https://seo.tbwakorea.com/blog/core-web-vitals/)
- [web.dev, 웹 바이탈](https://web.dev/articles/vitals?hl=ko)