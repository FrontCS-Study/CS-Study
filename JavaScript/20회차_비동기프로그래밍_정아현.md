# 비동기 프로그래밍



> 자바스크립트 엔진은 **단 하나의 실행 컨텍스트**를 갖는 **"싱글 스레드"**로 동작한다.
> 하지만, **브라우저 엔진의 이벤트 루프** 동작을 통해 비동기처리가 가능해진다.
> 기다려야 하는 일을 브라우저에 위임, 이때 끝나면 실행시킬 콜백을 등록해놓고, 위임된 일이 끝나면 그 결과와 콜백을 **"태스크 큐"에 추가**한다. 그리고 브라우저는 **"콜스택"이 비워질때마다**, 태스크 큐에서 오래된 작업을 꺼내와서 해당 작업에 대한 콜백을 실행시킨다. 이를 **"이벤트 루프"**라고 하고, 멀티스레드로 동작하며 비동기 작업이 가능해진다.



### 1. 동기 (Sync)와 비동기(Async) 처리

자바스크립트 엔진은 **단 하나의 실행 컨텍스트 스택**을 갖는다.
- 실행 컨텍스트 스택의 최상위 요소인 '실행 중인 실행 컨텍스트'를 제외한 모든 실행 컨텍스트는 모두 실행 대기중인 태스크

- 현재 실행 중인 함수가 종료되면 다음 태스크가 실행된다.

- 이처럼 자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 **싱글 스레드 방식**으로 동작한다.

- 처리에 시간이 걸리는 태스크를 실행하는 경우 **블로킹(작업 중단)**이 발생한다.

✅ 현재 실행 중인 **태스크가 종료할 때까지 다음에 실행될 태스크가 대기**하는 방식을 **동기처리**라고 한다.

✅ 현재 실행 중인 **태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행**하는 방식을 **비동기 처리** 라고 한다.

- 타이머 함수, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다.



### 2. 이벤트 루프(Event Loop)와 태스트 큐(Task Queue)

![이벤트루프](https://media.vlpt.us/images/aeong98/post/58f8f861-1d9a-41eb-a700-1488d2725034/image.png)

**자바스크립트의 동시성(concurrency)**을 지원하는 것이 **이벤트 루프** 이다.

자바스크립트 엔진은 크게 두 개의 영역으로 이루어져 있다.

✔**콜 스택(Call Stack, 호출 스택)**

- 소스코드(전역 코드나 함수 코드 등) 평가 과정에서 생성된 실행 컨택스트가 추가되고 제거되는 스택 자료구조인 실행 컨택스트 스택
- 함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행된다. 자바스크립트 엔진은 단 하나의 콜 스택을 사용하기 때문에, 최상위 실행 컨텍스트가 종료되어 콜 스택에서 제거되기 전까지는 다른 어떤 태스크도 실행되지 않는다.
- 실행 맥락에는 아래와 같은 정보들이 저장된다.
  - 함수 내부에서 사용되는 변수
  - 스코프 체인
  - `this`가 가리키는 객체

✔**힙(Heap)**

- 객체가 저장되는 메모리 공간
- 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.
- 메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야 한다. 객체는 원시 값과는 달리 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간의 크기를 런타임에 결정(동적 할당)해야 한다. 따라서 객체가 저장되는 메모리 공간의 힙은 구조화되어 있지 않다.

- **비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 Node.js가 담당한다.** 예를 들어, 비동기 방식으로 동작하는 setTimeout의 콜백 함수의 평가와 실행은 JS 엔진이 담당하지만 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저 또는 Node.js가 담당한다.

- 브라우저가 JS 코드를 실행시킬 때, 호출 스택은 다음과 같이 조작된다.
  1. 스크립트를 불러올 때, 전역 실행 맥락(Global Execution Context)을 호출 스택에 추가한다.
  2. 함수가 호출되면, 해당 호출에 대한 실행 맥락을 생성해서 호출 스택에 추가(Push)한다.
  3. 변수에 대입이 일어나면, 호출 스택에 저장되어 있는 변수의 내용을 변경한다.
  4. 함수의 실행이 끝나면 결과 값을 반환하고 호출 스택 가장 위에 있는 실행 맥락을 제거(Pop)한다.
  5. 스크립트의 실행이 모두 끝나면, 전역 실행 맥락을 호출 스택에서 제거(Pop)한다.

❗ **작업 큐(태스크 큐 / Task queue / Event queue / Callback queue)**

- `setTimeout`이나 `setInteval`와 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역. 태스크 큐와는 별도로 프로미스의 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 Microstack queue도 존재한다.

- 어떤 사건(event)가 일어날 때까지는 기다리거나, 혹은 큰 데이터에 대한 계산이 완료될 때까지 기다리는데 브라우저에는 **이벤트루프**를 통해서 오래 기다려야 하는 일을 처리할 수 있다.
  1. 기다려야 하는 일을 JS엔진에서 직접 처리하는 것이 아니라, API를 통해 브라우저에 위임한다. 이때, 끝나면 실행시킬 콜백을 같이 등록한다.
  2. 위임된 일이 끝나면, 그 결과와 콜백을 태스크 큐에 추가한다.
  3. 브라우저는 호출 스택이 비워질 때마다 태스크 큐에서 가장 오래된 작업을 꺼내와서 해당 작업에 대한 콜백을 실행시킨다. 
  4. 브라우저는 이 과정을 끊임없이 반복하는데, 이를 이벤트 루프라고 부른다.

❗ **이벤트 루프(Event Loop)**

- 이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨택스트가 있는지, 그리고 태스크 큐에 대기중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인한다.
- If (콜스택이 빔 && 대기 중인 함수 존재) => 이벤트 루프는 순차적으로 (FIFO) 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.

> 즉, 이벤트 루프는 자바스크립트가 아닌 브라우저에 내장되어 있는 기능 중 하나이다.
> 자바스크립트는 싱글스레드지만, **브라우저에서는 이벤트 루프 덕분에 멀티 스레드로 동작하며 비동기 작업이 가능하다.**



➰➕ **큐 우선순위**

큐는 크게 태스크 큐(task queue), 마이크로 태스트 큐(Micro task queue), rAF 큐(Request Animation Frame queue)로 나뉜다.

- **태스크 큐** : `setTimeout()`, `setInteval()`과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 대기하는 곳이다.
- **마이크로 태스트 큐** : `Promise()`의 후속 처리 메서드의 콜백 함수나 `MutationObserver()`가 대기하는 곳이다.
- **rAF 큐** :  `requestAnimationFrame()`처럼 애니메이션을 업데이트하는 콜백 함수가 대기하는 곳이다.

> **마이크로 태스트 큐 > rAF 큐 > 태스트 큐 순**이다.



### 비동기 처리

#### 1️⃣ 콜백함수 (Callback)

자바스크립트는 **비동기 처리를 위한 하나의 패턴**으로 콜백 함수를 사용한다. 하지만 전통적인 콜백 패턴은 콜백 지옥으로 인해 가독성이 나쁘고, 비동기 처리 중 발생한 **에러의 처리가 곤란**하며, **여러 개의 비동기 처리를 한 번에 처리하는데 한계**가 있다.

비동기 함수인 `setTimeout`은 콜백 함수의 **처리 결과를 외부로 반환하거나, 상위 스코프의 변수에 할당하지 못한다.**

```js
let g = 0;

setTimeout(() => {
    g = 100;
}, 0);
console.log(g);			// 0
```

❔ **콜백 지옥** : 콜백 함수의 후속 처리를 위해 비동기 함수가 비동기 처리 결과를 가지고 또 다시 비동기 함수를 호출해야 하는 경우, 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상

 #### 2️⃣ 프라미스(Promise)

Promise는 `then` 메서드를 통해 콜백을 등록해서, 작업이 끝났을 때 결과 값을 가지고 추가 작업을 할 수 있다.

Promise(ES6) 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달받는다.

- **`resolve`** : 성공했을 때 호출되는 콜백 함수
- **`reject`** : 실패했을 때 호출되는 콜백 함수

프로미스는 비동기 처리가 어떻게 진행되고 있는지를 나타내는 상태 정보를 갖는다.

- **`pending`** : 비동기 처리가 아직 수행되지 않은 상태(프로미스가 생성된 직후)
- **`fulfilled`** : 비동기 처리가 수행된 상태 (성공, `resolve` 함수 호출)
- **`rejected`** : 비동기 처리가 수행된 상태 (실패, reject 함수 호출)
- `fulfilled`와 `rejected`는 settled 상태고, 한 번 settled 상태가 되면 다른 상태로 변화될 수 없다.

✔**프로미스의 후속 처리 메서드**

- 후속 예외 처리를 위해 `then`, `catch`, `finally`를 제공한다.

- 프로미스의 비동기 처리 상태가 변화하면, 후속 처리 메서드에 인수로 전달한 콜백함수가 선택적으로 호출된다. 이때, 후속처리 메서드의 콜백함수에 프로미스의 처리 결과가 인수로 전달된다.

- 모든 후속처리 메서드는 프로미스를 반환하고, 비동기로 동작한다.

  ➰`Promise.prototype.then`

  - `then`메서드는 두 개의 콜백함수를 인수로 전달받는다.
  - fulfilled 상태, rejected 상태

  ➰ `Promise.prototype.catch`

  - catch 메서드는 한 개의 콜백함수를 인수로 전달받는다.
  - rejected 상태일 때만

  ➰ `Promise.prototype.finally`

  - finally 메서드는 한 개의 콜백함수를 인수로 전달받는다.
  - finally 메서드의 콜백함수는 프로미스의 성공(fulfilled) 또는 실패 (rejected)와 상관 없이 무조건 한 번만 호출된다.

### 3️⃣ 비동기 함수 async / await

async/await은 프로미스를 기반으로 동작하며 더 편한 환경에서 Promise를 다룰 수 있다.

async/await을 사용하면, 프로미스의 후속처리 메서드 없이, 마치 동기처럼 프로미스를 사용할 수 있다.

``` js
async function fetchTodo() {
    const url = "https://sdflkjk"
    const response = await fetch(url);
    
    const todo = await response.json;
    
    console.log(todo);
}
fetchTodo();
```

➰ **async** 함수

- `await` 키워드는 반드시 `async` 함수 내부에서 사용해야 한다.

- `async` 함수는 `async` 키워드를 사용해 정의하며 언제나 프로미스를 반환한다. 만약 promise가 아닌 값을 반환해도, `async`키워드로 정의된 함수는 JS에서 자동으로 그 값을 resolve promise로 감싸라고 지시한다.

➰ **await** 함수

- `await`키워드는 프로미스가 settled 인 상태가 될 때까지 대기하다가, settled 상대가 되면 프로미스가 resolve한 처리결과를 반환한다.
- 즉, `await`은 말 그대로 JS가 promise가 끝날 때까지 기다리게 만드는 것이다. 그 후에 promise의 결과 값을 갖고 다음 부분을 진행한다. 이 과정은 어떠한 CPU 리소스도 소모하지 않는다. 왜냐면 엔진이 그동안 다른 일을 할 수 있기 때문이다. 다른 스크립트를 실행하고 이벤트를 다루는 등의 일을 한다.
- `await`은 최상위 수준(top-level) 코드에서 작동하지 않는다. (async 안에 감싸야함)

➰ **에러처리**

- `try`, `catch`
- 후속 처리 메서드를 사용해 처리할 수도 있다.





## Reference

[자바스크립트 개발자라면 알아야 할 33가지 개념 #1 콜스택 (번역)](https://velog.io/@jakeseo_me/2019-03-15-2303-%EC%9E%91%EC%84%B1%EB%90%A8-rmjta5a3xh)

[자바스크립트 개발자라면 알아야 할 33가지 개념 #26 자바스크립트 : Async / Await](https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-33%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90-26-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Async-Await-2bjygyrlgw)

[[JS] 비동기 프로그래밍](https://velog.io/@aeong98/JS-%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D#-%EC%B6%9C%EC%B2%98)

[모던자바스크립트 DeepDive-42  비동기 프로그래밍](https://daniel-park.tistory.com/96)

[🔄 자바스크립트 이벤트 루프 동작 구조 & 원리 끝판왕](https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)
